> [목차](index.md)

## 11. 컬렉션 프레임웍

- [Collection framework](#collection-framework) 
	- [Collection framework와 핵심 인터페이스](#collection-framework%ec%99%80-%ed%95%b5%ec%8b%ac-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4)
- [Collection인터페이스](#collection%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4)
- [List인터페이스](#list%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4)
- [Set인터페이스](#set%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4)
- [Map인터페이스](#map%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4) 
	- [Map과 Iterator](#map%ea%b3%bc-iterator)
- [ArrayList](#arraylist) 
	- [관련 메서드](#%ea%b4%80%eb%a0%a8-%eb%a9%94%ec%84%9c%eb%93%9c)
- [Array](#array)
- [LinkedList](#linkedlist)
- [Stack과 Queue](#stack%ea%b3%bc-queue) 
	- [Stack](#stack) 
	- [Queue](#queue) 
	- [Stack과 Queue의 활용](#stack%ea%b3%bc-queue%ec%9d%98-%ed%99%9c%ec%9a%a9)
- [Iterator, ListIterator, Enumeration](#iterator-listiterator-enumeration)
- [Comparator와 Comparable](#comparator%ec%99%80-comparable)
- [HashSet](#hashset)
- [TreeSet](#treeset)
- [HashMap의 Key와 Value](#hashmap%ec%9d%98-key%ec%99%80-value)
- [Collection의 메서드\_동기화](#collection%ec%9d%98-%eb%a9%94%ec%84%9c%eb%93%9c%eb%8f%99%ea%b8%b0%ed%99%94)
- [Collection의 메서드\_변경불가,싱글톤,단일컬렉션](#collection%ec%9d%98-%eb%a9%94%ec%84%9c%eb%93%9c%eb%b3%80%ea%b2%bd%eb%b6%88%ea%b0%80%ec%8b%b1%ea%b8%80%ed%86%a4%eb%8b%a8%ec%9d%bc%ec%bb%ac%eb%a0%89%ec%85%98)
- [컬랙션 클래스 정리요약](#%ec%bb%ac%eb%9e%99%ec%85%98-%ed%81%b4%eb%9e%98%ec%8a%a4-%ec%a0%95%eb%a6%ac%ec%9a%94%ec%95%bd)

<br><br>
<br><br>

# Collection framework

- `JDK1.2`이전까지는 Vector,Hashtable,Properties와 같은 `Collection class` 등을 각각 처리해야 했으나 `JDK1.8`에 이르러서야 비로소 람다와 스트림에 의해 표준화를 이루었다.
- 다양한 종류의 `Collection class`들을, 인터페이스와 다형성등을 통해 객체지향적 설계 표준화를 제시한다.
- **라이브러리** : 공통으로 사용될만한 유용한 기능을 모듈화하여 제공
- **프레임웍** : 단순히 기능뿐만아니라 프로그래밍 방식을 정형화하여 프로그램의 개발 생산성을 높이고 유지보수를 용이하게 한다.

<br>

## Collection framework와 핵심 인터페이스

- 컬렉션 프레임웍의 모든 컬렉션 클래스들은 List, Set, Map 중의 하나를 구현하고 있으며 구현한 인터페이스의 이름이
  클래스의 이름에 포함되어 있어서 이름만으로도 클래스의 특징을 알 수 있다.

- Collection 
	- List : 순서가 있는 데이터의 집합. 데이터 중복을 허용한다. 
	- ArrayList 
	- LinkedList 
	- Stack 
	- Vector 
	- Set : 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다. 
	- HashSet 
	- TreeSet
- Map : Key, Value로 이루어진 데이터의 집합. 순서는 유지되지 않으며 값은 중복을 허용한다. 
	- HashMap 
	- TreeMap 
	- Hashtable 
	- Properties

<br><br>
<br><br>

# Collection인터페이스

- List와 Set의 조상
- 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는데 가장 기본적인 메서드등을 정의하고 있다.
  > :bulb: Java API문서에는 'E', 'K', 'V'등의 기호가 나오는데 이들은 모두 특정 타입을 의미하는 것으로 지네릭스에 의한 표기이다.
  > 모두 Object타입이라고 이해하면 된다.

| 메서드                            | 설명                                                                              |
| :-------------------------------- | :-------------------------------------------------------------------------------- |
| boolean add(Object o)             | 지적된 객체(o) 또는 Collection(c)의 객체들을 Collection에 추가한다.               |
| boolean addAll(Collection c)      | -                                                                                 |
| void clear()                      | Collection의 모든 객체를 삭제한다.                                                |
| boolean contains(Object o)        | 지정된 객체(o) 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인한다.  |
| boolean containsAll(Collection c) | -                                                                                 |
| boolean equals(Object o)          | 동일한 Collection인지 비교한다.                                                   |
| int hashCode()                    | Collection의 hash code를 반환한다.                                                |
| boolean isEmpty()                 | Collection이 비어있는지 확인한다.                                                 |
| iterator iterator()               | Collection의 iterator를 얻어서 반환한다.                                          |
| boolean remove(Object o)          | 지정된 객체를 삭제한다.                                                           |
| boolean removeAll(Collection c)   | -                                                                                 |
| boolean retainAll(Collection c)   | 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제한다. |
| int size()                        | Collection에 저장된 객체의 개수를 반환한다.                                       |
| Object[] toArray()                | Collection에 저장된 객체를 객체배열(Obejct[])로 변환한다.                         |
| Object[] toArray(Object[] a)      | -                                                                                 |

<br><br>
<br><br>

# List인터페이스

- 중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용된다.
- List - ArrayList - LinkedList - Vector - Stack

| 메서드                                   | 설명                                                                       |
| :--------------------------------------- | :------------------------------------------------------------------------- |
| void add(int index, Object element)      | 지정된 위치(index)에 객체(element) 또는 컬렉션에 포함된 객체들을 추가한다. |
| boolean addAll(int index, Collection c)  | -                                                                          |
| Object get(int index)                    | 지정된 위치(index)에 있는 객체를 반환한다.                                 |
| int indexOf(Object o)                    | 지정된 객체의 위치(index)를 반환한다. (순방향)                             |
| int lastIndex(Object o)                  | 지정된 객체의 위치(index)를 반환한다. (역방향)                             |
| ListIterator listIterator()              | List의 객체에 접근할 수 있는 ListIterator를 반환한다.                      |
| ListIterator listIterator(int index)     | -                                                                          |
| Object remove(int index)                 | 지정된 위치(index)에 객체를 삭제하고 삭제된 객체를 반환한다.               |
| Object set(int index, Object element)    | 지정된 위치(index)에 객체(element)를 저장한다.                             |
| void sort(Comparator c)                  | 지정된 비교자(comparator)로 List를 정렬한다.                               |
| List subList(int fromindex, int toIndex) | 지정된 범위(fromIndex부터 toIndex)에 있는 객체를 반환한다.                 |

<br><br>
<br><br>

# Set인터페이스

- 중복을 허용하지 않고 저장수선가 유지되지 않는 컬렉션 클래스를 구현하는데 사용된다.
- Set - HashSet - SortedSet - TreeSet

| 메서드                            | 설명                                                                              |
| :-------------------------------- | :-------------------------------------------------------------------------------- |
| boolean add(Object o)             | 지정된 객체(o) 또는 Collection(c)의 객체들을 Collection에 추가한다.               |
| boolean addAll(Collection c)      | -                                                                                 |
| void clear()                      | Collection의 모든 객체를 삭제한다.                                                |
| boolean contains(Obejct o)        | 지정된 객체(o) 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인한다.  |
| boolean containsAll(Collection c) | -                                                                                 |
| boolean equals(Object o)          | 동일한 Collection인지 비교한다.                                                   |
| int hashCode()                    | Collection의 hash code를 반환한다.                                                |
| boolean isEmpty()                 | Collection이 비어있는지 확인한다.                                                 |
| Iterator iterator()               | Collection의 Iterator를 얻어서 반환한다.                                          |
| boolean remove(Object o)          | 지정된 객체를 삭제한다.                                                           |
| boolean removeAll(Collection c)   | -                                                                                 |
| boolean retainAll(Collection c)   | 지정된 Collection에 포함된 객체만을 남기지 다른 객체들은 Collection에서 삭제한다. |
| int size()                        | Collection에 저장된 객체의 개수를 반환한다.                                       |
| Object[] toArray()                | Collection에 저장된 객체를 객체배열(Object[])로 반환한다.                         |
| Object[] toARray(Object[] a)      | 지정된 배열에 Collection의 객체를 저장해서 반환한다.                              |

<br><br>
<br><br>

# Map인터페이스

- Key와 Value을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는데 사용한다.
- 키는 중복될 수 없지만 값은 중복을 허용한다.
- 값(value)은 중복을 허용하기 때문에 `Collection`타입으로 반환하고, 키(key)는 중복을 허용하지 않기 때문에 `Set`타입으로 반환한다.
- Map 
	- Hashtable 
	- HashMap 
	- LinkedHashMap 
	- SortedMap 
	- TreeMap

| 메서드                               | 설명                                                                              |
| :----------------------------------- | :-------------------------------------------------------------------------------- |
| void clear()                         | Map의 모든 객체를 삭제한다.                                                       |
| boolean containsKey(Object key)      | 지정된 key객체와 일치하는 Map의 key객체가 있는지 확인한다.                        |
| boolean containsValue(Object value)  | 지정된 value객체와 일치하는 Map의 value객체가 있는지 확인한다.                    |
| Set entrySet()                       | Map에 저장되어 있는 key-value쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환한다. |
| boolean equals(Object o)             | 동일한 Map인지 비교한다.                                                          |
| Object get(Object key)               | 지정한 key객체에 대응하는 value객체를 찾아서 반환한다.                            |
| int hashCode()                       | 해시코드를 반환한다.                                                              |
| boolean isEmpty()                    | Map이 비어있는지 확인한다.                                                        |
| Set keySet()                         | Map에 저장된 모든 key객체를 반환한다.                                             |
| Object put(Object key, Object value) | Map에 value객체를 key객체에 연결(mapping)하여 저장한다.                           |
| void putAll(Map t)                   | 지정된 Map에 모든 key-value쌍을 추가한다.                                         |
| Obejct remove(Obejct key)            | 지정된 key객체와 일치하는 key-value객체를 삭제한다.                               |
| int size()                           | Map에 저장된 key-value쌍의 개수를 반환한다.                                       |
| Collection values()                  | Map에 저장된 모든 value객체를 반환한다.                                           |

<br>

## Map과 Iterator

- Map인터페이스를 구현한 컬렉션 클래스는 iterator()을 직접 호출할수 없다.
- 대신, `keySet()`이나 `entrySet()`과 같은 메서드를 통해서 키와 값을 각각 따로 Set와 형태로 얻어 온 후 다시 Iterator()를 호출해야한다.

```java
Iterator it = map.entrySet().iterator();
```

<br><br>
<br><br>

# ArrayList

- ArrayList는 Vector를 개선한 것으로 컬렉션 프레임웍에서 가장 많이 사용되는 컬렉션 클래스다.
- ArrayList는 List인터페이스를 구현하기 때문에, 데이터의 저장순서가 유지되고 중복을 허용한다는 특징을 갖는다.
  > :bulb: `java.util.Collection`은 인터페이스이고, `java.util.Collections`는 클래스임에 주의하자.

```java
public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, Java.io.Serializable{
	transient Obejct[] elementData; // 모든 종류의 객체를 담을 수 있다.
```

<br>

## 관련 메서드

| 메서드                                    | 설명                                                                                     |
| :---------------------------------------- | :--------------------------------------------------------------------------------------- |
| ArrayList()                               | 크기가 0인 ArrayList를 생성                                                              |
| ArrayList(Collection c)                   | 주어진 컬렉션이 저장된 ArrayList를 생성                                                  |
| ArrayList(int initialCapacity)            | -                                                                                        |
| boolean add(Object o)                     | ArrayList의 마지막에 객체를 추가. 성공하면 true                                          |
| void add(int index, Object elemet)        | 지정된 위치(index)에 객체를 저장                                                         |
| boolean addAll(Collection c)              | 주어진 컬렉션의 모든 객체를 저장한다.                                                    |
| boolean addAll(int index, Collection c)   | 지정된 위치부터 주어진 컬렉션의 모든 객체를 저장한다.                                    |
| void clear()                              | ArrayList를 완전히 비운다.                                                               |
| Object clone()                            | ArrayList를 복제한다.                                                                    |
| boolean contains(Object o)                | 지정된 객체(o)가 ArrayList에 포함되어 있는지 확인                                        |
| void ensureCapacity(int minCapacity)      | ArrayList의 용량이 최소한 minCapacity가 되도록 한다.                                     |
| Object get(int index)                     | 지정된 위치(index)에 저장된 객체를 반환한다.                                             |
| int indexOf(Object o)                     | 지정된 객체에 저장된 위치를 찾아 반환한다.                                               |
| boolean isEmpty()                         | ArrayList가 비어있는지 확인한다.                                                         |
| Iterator iterator()                       | ArrayList의 Iterator객체를 반환                                                          |
| int lastIndexOf(Object o)                 | 객체(o)가 저장된 위치를 끝부터 역방향으로 검색해서 반환                                  |
| ListIteraotr listIterator()               | ArrayList의 ListIterator를 반환                                                          |
| ListIteraotr listIteraotr(int index)      | ArrayList의 지정된 위치부터 시작하는 ListIterator를 반환                                 |
| Object remove(int index)                  | 지정된 위치(index)에 있는 객체를 제거한다.                                               |
| boolean remove(Object o)                  | 지정된 객체를 제거한다. (성공하면 true, 실패하면 false)                                  |
| boolean removeAll(Collection c)           | 지정된 컬렉션에 저장된 것과 동일한 객체들을 ArrayList에서 제거한다.                      |
| boolean retainAll(Collection c)           | ArrayList에 저장된 객체 중에서 주어진 컬렉션과 공통된 것들만을 남기고 나머지는 삭제한다. |
| Object set(int index, Obejct element)     | 주어진 객체(element)를 지정된 위치(index)에 저장한다.                                    |
| int size()                                | ArrayList에 저장된 객체의 개수를 반환한다.                                               |
| void sort(Comparator c)                   | 지정된 정렬기준(c)으로 ArrayList를 정렬                                                  |
| List subList(int fromIndex, int tolIndex) | fromIndex부터 toIndex사이에 저장된 객체를 반환한다.                                      |
| Object[] toArray()                        | ArrayList에 저장된 모든 객체들을 객체배열로 반환한다.                                    |
| Object[] toArray(Object[] a)              | ArrayList에 저장된 모든 객체들을 객체배열 a에 담아 반환한다.                             |
| void trimToSize()                         | 용량을 크기에 맞게 줄인다. (빈 공간을 없앤다.)                                           |

```java
import java.util.*;

class Ex11_1 {
	public static void main(String[] args) {
		ArrayList list1 = new ArrayList(10);
		list1.add(new Integer(5));
		list1.add(new Integer(4));
		list1.add(new Integer(2));
		list1.add(new Integer(0));
		list1.add(new Integer(1));
		list1.add(new Integer(3));

		ArrayList list2 = new ArrayList(list1.subList(1,4));
		print(list1, list2);

		Collections.sort(list1);	// list1과 list2를 정렬한다.
		Collections.sort(list2);	// Collections.sort(List l)
		print(list1, list2);

		System.out.println("list1.containsAll(list2):"+ list1.containsAll(list2));

		list2.add("B");
		list2.add("C");
		list2.add(3, "A"); // 인덱스가 3인 곳에 "A"를 추가
		print(list1, list2);

		list2.set(3, "AA"); // 인덱스가 3인 곳을 "AA"로 변경
		print(list1, list2);

		System.out.println("list1.retainAll(list2):" + list1.retainAll(list2)); // list1에서 list2와 겹치는 부분만 남기고 나머지는 삭제한다.
		print(list1, list2);

		for(int i= list2.size()-1; i >= 0; i--) { //  list2에서 list1에 포함된 객체들을 삭제한다.
			if(list1.contains(list2.get(i)))
				list2.remove(i); // 인덱스가 i인 곳에 저장된 요소를 삭제
		}
		print(list1, list2);
	} // main끝

	static void print(ArrayList list1, ArrayList list2) {
		System.out.println("list1:"+list1);
		System.out.println("list2:"+list2);
		System.out.println();
	}
} // class
```

- ArrayList의 `insert()`와 `remove()` 
	1. 삭제할 데이터의 아래에 있는 데이터를 한 칸씩 위로 복사해서 삭제할 데이터를 덮어쓴다. 
	2. 데이터가 모두 한 칸씩 위로 이동하였으므로 마지막 데이터는 null로 변경해야한다. 
	3. 데이터가 삭제되어 데이터의 개수(size)가 줄었으므로 size의 값을 1감소 시킨다. 
	- (데이터의 수정이 많을 수록 작업시간이 오래 걸린다.)
  > :bulb: `src\java\util\Vector.java` Java API 소스는 오랜 경력의 전문프로그래머들의 의해서 작성된 것이기 때문에 어떻게 작성하였는지 보고 따라하는 것은 프로그래밍실력을 향상시키는데 많은 도움이 될 것이다.

<br><br>
<br><br>

# Array

- `copyOf()` : 배열전체
- `copyOfRange()` : 배열의 일부 복사
- `fill()` : 배열의 모든 요소를 지정된 값으로 채운다.
- `setAll()` : 함수형 인터페이스를 매개변수로 받는다.
- `equals()` : 일차원배열에서
- `toString()` : 일차원배열에서
- `deepEquals()` : 다차원배열에서
- `deepToString()` : 다차원배열에서
- `sort()`
- `binarySearch()` : 배열에서 지정된 값이 저장된 위치(index)를 찾아서 반환 (정렬 되어있어야함) 
	- 순차 검색(linear search) : 첫 번쨰 요소부터 순서대로 하나씩 검색, 비교하는데 시간이 오래걸림 
	- 이진 검색(binary search) : 배열의 검색할 범위를 절반씩 줄여가며 검색, 정렬이 되어있는 경우만
- `asList(Obejct... a)` : 매개변수의 타입이 가변인수라서 배열 생성없이 저장할 요소들만 나열하는 것도 가능하다.
- `parallelXXX()`, `spliterator()`, `stream()` : 여러 쓰레드가 나누어 처리하도록 한다.

|        | Array                                     | ArrayList                                                                                   |
| :----- | :---------------------------------------- | :------------------------------------------------------------------------------------------ |
| 사이즈 | 초기화시 고정 int[] myArray = new int[6]; | 초기화시 사이즈를 표시하지 않음. 유동적 ArrayList<Integer> myArrayList = new ArrayList<>(); |
| 속도   | 초기화시 메모리에 할당되어 속도가 빠르다  | 추가시 메모리를 재할당하여 속도가 느리다.                                                   |
| 변경   | 사이즈 변경 불가                          | add(), remove()로 가능                                                                      |
| 다차원 | int[][][] multiArray = new int[3][3][3]   | 불가능                                                                                      |

```java
import java.util.ArrayList;
import java.util.Arrays;

public class Main {

    public static void main(String[] args) {

        int[] myArray = new int[6];
        myArray[1]=100;
        //myArray[7]= 10; // ArraysOutOfBoundException

        //Declaration of ArrayList. Add and Remove of elements is easy.
        ArrayList<Integer> myArrayList = new ArrayList<>();
        myArrayList.add(1);
        myArrayList.add(2);
        myArrayList.add(3);
        myArrayList.add(4);
        myArrayList.add(5);
        myArrayList.remove(0);

        for(int i = 0; i < myArrayList.size(); i++) {
            System.out.println("Element: " + myArrayList.get(i));
        }


        System.out.println(Arrays.toString(myArray));


        //Multi-dimensional Array
        int[][] multiArray = new int [3][3];

        multiArray[0][0]=1;
        multiArray[0][1]=2;
        multiArray[0][2]=3;

        multiArray[1][0]=4;
        multiArray[1][1]=5;
        multiArray[1][2]=6;

        multiArray[2][0]=7;
        multiArray[2][1]=8;
        multiArray[2][2]=9;

        System.out.println(Arrays.deepToString(multiArray).replaceAll("],", "]," + System.getProperty("line.separator")));

    }
}
```

```java
int[] arr = enw int[5];
Arrays.fill(arr, 9);
Arrays.setAll(arr, (i) -> (int)(Math.random()*5)+1); // arr=[1,5,2,1,1] 람다식

List list = Arrays.asList(new Integer[]{1,2,3,4,5});
List list = Arrays.asList(1,2,3,4,5);
list.add(6);
```

<br><br>
<br><br>

# LinkedList

- 데이터의 개수가 변하지 않는 경우라면 `ArrayList`, 데이터 개수의 변경이 잦다면 `LinkedList`
- `Array` 
	- 모든 데이터가 연속적으로 존재하여 접근시간(access time)이 가장 빠르다 
	- 순차적인 추가삭제는 빠르다, 비효율적인 메모리사용 
	- 크기를 변경할 수 없다. 
	- 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다. 
	- ( 인덱스가 n인 데이터의 주소 = 배열의주소 + n \* 데이터타입의크기 )
- `Linked list` 
	- 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있다. 
	- 배열처럼 데이터를 이동하기 위해 복사하는 과정이 없기 때문에 처리속도가 매우 빠르다. 
	- 저장해야하는 데이터의 개수가 많아질수록 데이터를 읽어 오는 시간 즉 접근시간(access Time)이 길어진다. 
	- ( 인덱스가 n인 데이터의 주소 = n번째 데이터까지 차례대로 따라가야함. )

```java
class Node{
	Node next;
	Object obj;
}
```

<br><br>
<br><br>

# Stack과 Queue

## Stack

- LIFO(Last In First Out)
- 순차적으로 데이터를 추가하고 삭제 `push` -> `pop`
- `ArrayList`와 같은 배열기반의 컬랙션 클래스가 적합

| 메서드                   | 설명                                                                                                          |
| :----------------------- | :------------------------------------------------------------------------------------------------------------ |
| boolean empty()          | Stack이 비어있는지 알려준다.                                                                                  |
| Object peek()            | Stack의 맨 위에 저장된 객체를 반환. pop()과 달리 Stack에서 객체를 꺼내지는 않음.                              |
| Object pop()             | Stack의 맨 위에 저장된 객체를 꺼낸다. (비었을 때는 EmptyStackException발생)                                   |
| Object push(Object item) | Stack에 객체(item)를 저장한다.                                                                                |
| int search(Obejct o)     | Stack에서 주어진 객체(o)를 찾아서 그 위치를 반환. 못찾으면 -1을 반환. (배열과 달리 위치는 0이 아닌 1부터 시작 |

```java
import java.util.*;

public class Ex11_3 {
	public static void main(String[] args) {
		if (args.length != 1) {
			System.out.println("Usage:java Ex11_3 \"EXPRESSION\"");
			System.out.println("Example:java Ex11_3 \"((2+3)*1)+3\"");
			System.exit(0);
		}

		Stack st = new Stack();
		String expression = args[0];

		System.out.println("expression:" + expression);

		try {
			for (int i = 0; i < expression.length(); i++) {
				char ch = expression.charAt(i);

				if (ch == '(') {
					st.push(ch + "");
				} else if (ch == ')') {
					st.pop();
				}
			}

			if (st.isEmpty()) {
				System.out.println("괄호가 일치합니다.");
			} else {
				System.out.println("괄호가 일치하지 않습니다..");
			}
		} catch (EmptyStackException e) {
			System.out.println("괄호가 일치하지 않습니다.");
		} // try
	}
}
```

<br>

## Queue

- FIFO(First In First Out)
- 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제한다. `offer` -> `poll`
- ArrayList보다 데이터의 추가, 삭제가 쉬운 `LinkedList`로 구현하는 것이 더 적합하다.

| 메서드                  | 설명                                                                                                |
| :---------------------- | :-------------------------------------------------------------------------------------------------- |
| boolean add(Object o)   | 지정된 객체를 Queue에 추가한다. 성공하면 true를 반환. 저장공간이 부족하면 illegalStateException발생 |
| Object remove()         | Queue에서 객체를 꺼내 반환. 비어있으면 NoSuchElementException발생                                   |
| Object element()        | 삭제없이 요소를 읽어본다. peek와 달리 Queue가 비었을 때 NoSuchElementException발생                  |
| boolean offer(Object o) | Queue에 객체를 저장. 성공하면 true, 실패하면 false를 반환                                           |
| Object poll()           | Queue에서 객체를 꺼내서 반환. 비어있으면 null을 반환                                                |
| Object peek()           | 삭제없이 요소를 읽어 온다. Queue가 비어있으면 null을 반환                                           |

```java
import java.util.*;

class Ex11_2 {
	public static void main(String[] args) {
		Stack st = new Stack();
		Queue q = new LinkedList();	// Queue인터페이스의 구현체인 LinkedList를 사용

		st.push("0");
		st.push("1");
		st.push("2");

		q.offer("0");
		q.offer("1");
		q.offer("2");

		System.out.println("= Stack =");
		while(!st.empty()) {
			System.out.println(st.pop()); // 스택에서 요소 하나를 꺼내서 출력
		}

		System.out.println("= Queue =");
		while(!q.isEmpty()) {
			System.out.println(q.poll()); // 큐에서 요소 하나를 꺼내서 출력
		}
	}
}
```

> :bulb: 자바에서는 스택을 Stack클래스로 구현하여 제공하고 있지만 큐는 Queue인터페이스로만 정의해 놓았을 뿐 별도의 클래스를 제공하고 있지 않다.
> 대신 Queue인터페이스를 구현한 클래스들을 찾고자 할 때는 Java API문서를 참고하여 `All Known Implementing Classes`에 나열된 클래스를 골라 사용하면 된다.  
> <br>

## Stack과 Queue의 활용

- 스택의 활용 예 : 수식계산, 수식괄호검사, 워드프로세스의 undo/redo, 웹브라우저의 뒤로/앞으로
- 큐의 활용 예 : 최근사용문서, 인쇄작업 대기목록, 버퍼(buffer)

<br><br>
<br><br>

# Iterator, ListIterator, Enumeration

- Collection인터페이스에 정의된 메서드이며 컬렉션에 저장된 요소를 접근하는데 사용하는 인터페이스이다.
- List나 Set인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 맞게 작성되어 있다.
- `Iterator` : 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스
- `ListIterator` : Iterator에 양방향 조회기능추가(List를 구현한 경우만 사용가능)
- `Enumeration` : Iteraotr의 구버전

```java
public interface Iterator {
	boolean hasNext();
Object next();
void remove();
}
```

```java
public interface Collection{
	public Iterator iterator();
}
```

```java
import java.util.*;

class Ex11_5 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		list.add("1");
		list.add("2");
		list.add("3");
		list.add("4");
		list.add("5");

		Iterator it = list.iterator();

		while(it.hasNext()) { // for(int i=0; i<list.size(); i++)로 대체가능
			Object obj = it.next();
			System.out.println(obj);
		}
	} // main
}
```

<br><br>
<br><br>

# Comparator와 Comparable

- 인터페이스로 컬렉션을 정렬하는데 필요한 메서드를 정의하고 있다.
- `Comparable`을 구현하고 있는 클래스들은 Integer와 같은 wrapper클래스와 String, Date, File 등이다.
- `Comparable`은 오른차순으로 정렬이 가능하다.
- `Comparator` : 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용
- `compareTo()`를 구현해서 어떤 비교기준으로 정렬할지 정해줄 수 있다.

```java
public interface Comparator{
	int compare(Object o1, Object o2);
	boolean equals(Object obj);
}
public interface Comparable{
	int compareTo(Object o);
}
```

```java
static void sort(Obejct[] a);
static void sort(Obejct[] a, Comparator c);
```

```java
import java.util.*;

class Ex11_7 {
	public static void main(String[] args) {
		String[] strArr = {"cat", "Dog", "lion", "tiger"};

		Arrays.sort(strArr); // String의 Comparable구현에 의한 정렬
		System.out.println("strArr=" + Arrays.toString(strArr));

		Arrays.sort(strArr, String.CASE_INSENSITIVE_ORDER); // 대소문자 구분안함
		System.out.println("strArr=" + Arrays.toString(strArr));

		Arrays.sort(strArr, new Descending()); // 역순 정렬
		System.out.println("strArr=" + Arrays.toString(strArr));
	}
}

class Descending implements Comparator {
	public int compare(Object o1, Object o2){
		if( o1 instanceof Comparable && o2 instanceof Comparable) {
			Comparable c1 = (Comparable)o1;
			Comparable c2 = (Comparable)o2;
			return c1.compareTo(c2) * -1 ; // -1을 곱해서 기본 정렬방식의 역으로 변경한다.
			// 또는 c2.compareTo(c1)와 같이 순서를 바꿔도 된다.
		}
		return -1;
	}
}
```

```java
// 대소문자를 구분하지 않고 비교하는 Comparator를 상수의 형태로 제공한다.
public static final Comparator CASE_INSENSITIVE_ORDER;
```

<br><br>
<br><br>

# HashSet

- Set인터페이스를 구현한 대표적인 컬렉션
- ArrayList와 같이 List인터페이스를 구현한 컬렉션과 달리 `HashSet`은 저장순서를 유지하지 않으므로 저장순서를 유지하고자 한다면 `LinkedHashSet`을 사용해야 한다.

| 생성자 또는 메서드                             | 설명                                                                                 |
| :--------------------------------------------- | :----------------------------------------------------------------------------------- |
| HashSet()                                      | HashSet객체를 생성한다.                                                              |
| HeshSet(Collection c)                          | 주어진 컬렉션을 포함하는 HashSet객체를 생성한다.                                     |
| HashSet(int initialCapacity)                   | 주어진 값을 초기용량으로하는 HashSet객체를 생성한다.                                 |
| HashSet(int initialCapacity, float loadFactor) | 초기용량과 loadfactor를 지정하는 생성자                                              |
| boolean add(Object o)                          | 새로운 객체를 저장한다.                                                              |
| boolean addAll(Collection c)                   | 주어진 컬렉션에 저장된 모든 객체들을 추가한다. (합집합)                              |
| void char()                                    | 저장된 모든 객체를 삭제한다.                                                         |
| Object clone()                                 | HashSet을 복제해서 반환한다 (얕은복사)                                               |
| boolean contains(Object o)                     | 지정된 객체를 포함하고 있는지 알려준다.                                              |
| boolean containsAll(Collection c)              | 주어진 컬렉션에 저장된 모든 객체들을 포함하고 있는지 알려준다.                       |
| boolean inEmpty()                              | HashSet이 비어있는지 알려준다.                                                       |
| Iterator iterator()                            | iterator를 반환한다.                                                                 |
| boolean remove(Obejct o)                       | 지정된 객체를 HashSet에서 삭제한다.                                                  |
| boolean removeAll(Collection c)                | 주어진 컬렉션에 저장된 모든 객체와 동일한 것들을 HashSet에서 모두 삭제한다. (합집합) |
| boolean retainAll(Collection c)                | 주어진 컬렉션에 저장된 객체와 동일한 것만 남기고 삭제한다. (교집합)                  |
| int size()                                     | 저장된 객체의 개수를 반환한다.                                                       |
| Object[] toArray()                             | 저장된 객체들을 객체배열의 형태로 반환한다.                                          |
| Object[] toArray(Object[] a)                   | 저장된 객체들을 주어진 객체배열(a)에 담는다.                                         |

```java
import java.util.*;

class Ex11_8 {
	public static void main(String[] args) {
		Object[] objArr = {"1",new Integer(1),"2","2","3","3","4","4","4"}; // String인스턴스와 Integer인스턴스를 중복으로 간주하지 않는다.
		Set set = new HashSet();

		for(int i=0; i < objArr.length; i++) {
			set.add(objArr[i]);	// HashSet에 objArr의 요소들을 저장한다.
		}
      // HashSet에 저장된 요소들을 출력한다 (Iterator이용)
		System.out.println(set);
	}
}
```

```java
import java.util.*;

class Ex11_9 {
	public static void main(String[] args) {
		Set set = new HashSet();

		for (int i = 0; set.size() < 6 ; i++) {
			int num = (int)(Math.random()*45) + 1;
			set.add(new Integer(num));
		}

		//sort()을 사용하기위해 매개변수 타입으로 변환하였음.
		List list = new LinkedList(set); // LinkedList(Collection c)
		Collections.sort(list);          // Collections.sort(List list)
		System.out.println(list);
	}
}
```

```java
import java.util.*;

class Ex11_11 {
	public static void main(String[] args) {
		HashSet set = new HashSet();

		set.add("abc");
		set.add("abc");
		set.add(new Person("David",10));
		set.add(new Person("David",10));

		System.out.println(set);
	}
}

class Person {
	String name;
	int age;

	Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public String toString() {
		return name +":"+ age;
	}

	//HashSet의 add메서드는 새로운 요소를 추가하기 전에 기존에 저장된 요소와 같은 것인지 판별하기 위해 추가하려는 요소의 equals()와 hashCode()를 호출하기 때문에 오버라이딩하였음.
	public boolean(Obejct obj){
		if(!(obj instanceof Person)) return false;
		Person p = (Person)obj;
		return name.equals(p.name) && age == p.age;
	}
	public int hashCode(){
		return Objects.hash(name, age);
	}
}
```

<br><br>
<br><br>

# TreeSet

- 이진 검색 트리(binary search tree) - 모든 노드는 최대 두 개의 자식노드를 가질 수 있다. 
	- 원쪽 자식노드의 값은 부모노드의 값보다 작고 오른쪽 자식노드의 값은 부모노드의 값보다 커야한다. 
	- 노드의 추가 삭제에 시간이 걸린다. (순차적으로 저장하지 않으므로) 
	- 항상 정렬된 상태를 유지하므로 단일 값 검색과 범위검색(range search)가 빠르다. 
	- `Set 인터페이스`를 구현했으므로 중복된 데이터의 저장을 허용하지 않는다. 
	- 정렬된 위치에 저장하므로 저장순서를 유지하지 않는다.
  > :bulb: `TreeSet`에 저장되는 객체가 `Comparable`을 구현하던가 아니면, `Comparator`를 제공해서 두 객체를 비교할 방법을 알려줘야 한다.
  > 그렇지 않으면, TreeSet에 객체를 저장할 때 예외가 발생한다.

```java
class TreeNode{
	TreeNode left;
	Object element;
	TreeNode right;
}
```

| 생성자 또는 메서드                                                                                   | 설명                                                                             |
| :--------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------- |
| TreeSet()                                                                                            | 기본 생성자                                                                      |
| TreeSet(Collcetion c)                                                                                | 주어진 컬렉션을 저장하는 TreeSet을 생성                                          |
| TreeSet(Comparator comp)                                                                             | 주어진 정렬조건을 정렬하는 TreeSet을 생성                                        |
| TreeSet(SortedSet a)                                                                                 | 주어진 컬렉션(SortedSet구현) s를 저장하는 TreeSet생성                            |
| boolean add(Object o)                                                                                | 지정된 객체(o) 또는 Collection(C)의 객체들을 Collection에 추가                   |
| boolean addAll(Collection c)                                                                         | -                                                                                |
| Object Ceiling(Object o)                                                                             | 지정된 객체와 같은 객체를 반환. 없으면 큰 값을 반환, 없으면 null                 |
| void clear()                                                                                         | 저장된 모든 객체 삭제                                                            |
| Obejct clone()                                                                                       | TreeSet을 복제하여 반환                                                          |
| Comparator comparator()                                                                              | TreeSet의 정렬기준(Comparator)를 반환                                            |
| boolean contains(Object o)                                                                           | 지정된 객체(o) 또는 Collection의 객체들이 모두 포함되어 있는지 확인              |
| boolean containsAll(Collection c)                                                                    | -                                                                                |
| NavigableSet descendingSet()                                                                         | TreeSet에 저장된 모든 요소들을 역순으로 정렬해서 반환                            |
| Object first()                                                                                       | 정렬된 순서에서 첫 번째 객체를 반환                                              |
| Object floor(Object o)                                                                               | 지정된 객체와 같은 객체를 반환. 없으면 작은 값을 반환, 없으면 null               |
| SortedSet headSet(Obejct toElement)                                                                  | 지정된 객체보다 작은 값의 객체들을 반환                                          |
| NavigableSet headSet(Object toElement, boolean inclusive)                                            | 지정된 객체보다 작은 값의 객체들을 반환, 같은 값 포함 유무                       |
| Object highter(Object o)                                                                             | 지정된 객체보다 큰 값을 가진 객체 중 가장 가까운 값의 객체를 반환, 없으면 null   |
| boolean isEmpty()                                                                                    | TreeSet이 비어있는지 확인                                                        |
| Iterator iterator()                                                                                  | TreeSet의 Iterator를 반환                                                        |
| Object last()                                                                                        | 정렬된 순서에서 마지막 객체를 반환                                               |
| Object lower(Object o)                                                                               | 지정된 객체보다 작은 값을 가진 객체 중 가장 가까운 값의 객체를 반환, 없으면 null |
| Object pollFirst()                                                                                   | TreeSet의 첫번쨰 요소(제일 작은 값의 객체)를 반환.                               |
| Object pollLast()                                                                                    | Treeset의 마지막 번째 요소(제일 큰ㄱ밧의 객체)를 반환.                           |
| boolean remove(Obejct o)                                                                             | 지정된 객체를 삭제                                                               |
| boolean retainAll(Collection c)                                                                      | 주어진 컬렉션과 공통된 요소만을 남기고 삭제 (교집합)                             |
| int size()                                                                                           | 저장된 객체의 개수를 반환                                                        |
| Spliterator spliator()                                                                               | TreeSet의 Spliterator를 반환                                                     |
| SortedSet subSet(Obejct fromElement, Object toElement)                                               | 범위 검색(fromElement와 toElement사이)의 결과를 반환한다.                        |
| NavigableSet subSet(Object fromElement, boolean fromInclusive, Object toElement, boolean ioInclusive | 범위 검색(fromElement와 toElement사이)의 결과를 반환한다, 처음과 끝 값 포함 유므 |
| SortedSet tailSet(Object fromElement)                                                                | 지정된 객체보다 큰 값의 객체들을 반환한다.                                       |
| Object[] toArray()                                                                                   | 저장된 객체를 객체배열로 반환한다.                                               |
| Object[] toArray(Object[] a)                                                                         | 저장된 객체를 주어진 객체배열에 저장하여 반환한다.                               |

```java
import java.util.*;

class Ex11_14 {
	public static void main(String[] args) {
		TreeSet set = new TreeSet();

		String from = "b";
		String to	= "d";

		set.add("abc");      set.add("alien");    set.add("bat");
		set.add("car");      set.add("Car");      set.add("disc");
		set.add("dance");    set.add("dZZZZ");    set.add("dzzzz");
		set.add("elephant"); set.add("elevator"); set.add("fan");
		set.add("flower");

		System.out.println(set);
		System.out.println("range search : from " + from  +" to "+ to);
		System.out.println("result1 : " + set.subSet(from, to));
		System.out.println("result2 : " + set.subSet(from, to + "zzz")); // 범위검색
	}
}
```

```java
import java.util.*;

class Ex11_15 {
	public static void main(String[] args) {
		TreeSet set = new TreeSet();
		int[] score = {80, 95, 50, 35, 45, 65, 10, 100};

		for(int i=0; i < score.length; i++)
			set.add(new Integer(score[i]));

		System.out.println("50보다 작은 값 :" + set.headSet(new Integer(50)));
		System.out.println("50보다 큰 값 :"  + set.tailSet(new Integer(50)));
	}
}
```

<br><br>
<br><br>

# HashMap의 Key와 Value

- Map을 구현한 인스턴스로, Key와 Value을 묶어서 하나의 데이터(Entity)로 저장한다.
- 해싱(hasing)을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보인다.
- `Hashtable`은 key나 value로 null을 허용하지 않지만, `HashMap`은 허용한다.

```java
public class HashMap extends AbstractedMap implements Map, Cloneable, Serializable{
	transient Entry[] table;
	...

	static class Entry implements Map.Entry{
		final Object key;
		Object value;
	}

}
```

| 생성자 또는 메서드                                            | 설명                                                                               |
| :------------------------------------------------------------ | :--------------------------------------------------------------------------------- |
| HashMap()                                                     | HashMap객체를 생성                                                                 |
| HashMap(int initialCapacity)                                  | 지정된 값을 초기용량으로 하는 HashMap객체를 생성                                   |
| HashMap(int initialCapacity, float loadFactor)                | 지정된 초기용량과 load factor의 HashMap객체를 생성                                 |
| HashMap(Map m)                                                | 지정된 Map의 모든 요소를 포함하는 HashMap을 생성                                   |
| void clear()                                                  | HashMap에 저장된 모든 객체를 제거                                                  |
| Object clone()                                                | 현재 HashMap을 복제해서 반환                                                       |
| boolean containsKey(Object Key)                               | HashMap에 지정된 Key가 포함되어있는지 알려준다.                                    |
| boolean containsValue(Object value)                           | HashMap에 지정된 value이 포함되어있는지 알려준다.                                  |
| set entrySet()                                                | HashMap에 저장된 key와 value을 엔트리(키와 값의 결합)의 형태로 Set에 저장해서 반환 |
| Object get(Object key)                                        | 지정된 key와 value를 반환, 못찾으면 null                                           |
| Obejct getOrDefalut(Object ket, Object defalutValue)          | 지정된 key와 value를 반환, 못찾으면 지정된 객체를 반환                             |
| boolean isEmpty()                                             | HashMap이 비어있는지 알려준다.                                                     |
| Set keySet()                                                  | HashMap에 저장된 모든 키가 저장된 Set을 반환                                       |
| Object put(Object key, Object value)                          | 지정된 키와 값을 HashMap에 저장                                                    |
| void putAll(Map m)                                            | Map에 저장된 모든 요소를 HashMap에 저장                                            |
| Object remove(Object key)                                     | HashMap에서 저장된 key로 저장된 value(객체)를 제거                                 |
| Object replace(Object key, Object value)                      | 지정된 key의 value를 지정된 객체(value)로 대체                                     |
| boolean replace(Object key, Object oldValue, Object newValue) | 지정된 key와 객체(oldValue)가 모두 일치하는 경우에만 새로운 객체(newValue)로 대체  |
| int size()                                                    | HashMap에 저장된 요소의 개수를 반환                                                |
| Collection values()                                           | HashMap에 저장된 모든 값을 컬렉션의 형태로 반환                                    |

<br><br>
<br><br>

# Collection의 메서드\_동기화

- 멀티 쓰레드(multi-thread)의 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 **무결성**(integrity)을 유지하기 위해서는 공유되는 객체에 **동기화**(synchronization)가 필요하다.
- `ArrayList와 HashMap`과 같은 컬랙션은 동기화를 자체적으로 처리하지 않고 필요한 경우에만 `java.util.Collections`클래스의 동기화 메서드를 이용해서 동기화 처리가 가능하도록 하였다.

```java
static Collection synchronizationCollection(Collection c)
static List synchronizationList(List list)
static Set synchronizationSet(Set s)
static Map synchronizationMap(Map m)
static SortedSet synchronizationSortedSet(SortedSet s)
static SortedMap synchronizationSortedMap(SortedMap m)
```

```java
List syncList = Collections.synchronizationList(new ArrayList(...));
```

<br><br>
<br><br>

# Collection의 메서드\_변경불가,싱글톤,단일컬렉션

- **읽기전용** : 여러 쓰레드가 하나의 컬렉션을 공유하다보면 데이터가 손상될 수 있는데, 이를 방지하려면 아래의 메서드들을 이용하자.

```java
static Collection unmodifiableCollection(Collection c)
static List unmodifiableList(List list)
static Set unmodifiableSet(Set s)
static Map unmodifiableMap(Map m)
static SortedSet unmodifiableSortedSet(SortedSet s)
static SortedMap unmodifiableSortedMap(SortedMap m)
```

- **싱글톤** : 단 하나의 객체만을 저장하는 컬렉션을 만들어야하는 경우가 있다.

```java
static List singletonList(List list)
static Set singletonSet(Set s)
static Map singletonMap(Map m)
```

- **단일 컬렉션** : 컬렉션은 모든 정류의 객체를 저장할 수 있지만 한 종류만 저장할 수 있도록 한다. - 지네릭스(generics)로 간단히 처리할 수 있으나 호환성 때문에 제공.

```java
static Collection checkCollection(Collection c)
static List checkList(List list)
static Set checkSet(Set s)
static Map checkMap(Map m)
static Map checkQueue(Queue queue, Class type)
static NavigableSet checkNavigableSet(NavigableSet s, Class type)
static SortedSet checkSortedSet(SortedSet s)
static checkNavigableMap checkNavigableMap(checkNavigableMap s, Class keyType, Class valueType)
static SortedMap checkSortedMap(SortedMap m, Class keyType, Class valueType)
```

```java
List list = new ArrayList();
List checkedList = checkedList(list, String.class);
checkedList.add("abc");
// checkedList,add(new Integer(3));
```

<br><br>
<br><br>

# 컬랙션 클래스 정리요약

- `ArrayList`, `Vector` 
	- (추가,삭제기능 향상)`LinkedList` 
		- `Queue` 
		- (검색, 범위검색, 정렬기능 향상)`TreeMap` 
			- `TreeSet` 
	- (검색기능향상)`HashMap`, `Hashtable` 
		- `Properties` 
		- (순서유지기능 향상)`LinkedHashMap` 
		- `HashSet` 
			- (순서유지기능 향상)`LinkedHashSet` 
	- `Stack`

| 컬렉션        | 특징                                                                                                                     |
| :------------ | :----------------------------------------------------------------------------------------------------------------------- |
| ArrayList     | 배열기반, 데이터의 추가와 삭제에 불리, 순차적인 추가삭제는 제일 빠름. 임의의 요소에 대한 접근성(accessibility)이 뛰어남. |
| LinkedList    | 연결기반, 데이터의 추가와 삭제에 유리. 임의의 요소에 대한 접근성이 좋지 않다.                                            |
| HashMap       | 배열과 연결이 결합된 형태, 추가, 삭제, 검색, 접근성이 모두 뛰어남. 검색에는 최고의 성능을 보인다.                        |
| TreeMap       | 연결기반. 정렬과 범위검색에 적합. 검색성능은 HashMap보다 떨어짐                                                          |
| Stack         | Vector를 상속받아 구현                                                                                                   |
| Queue         | LinkedList가 Queue인터페이스를 구현                                                                                      |
| Properties    | Hashtable을 상속받아 구현                                                                                                |
| HashSet       | HashMap을 이용해서 구현                                                                                                  |
| TreeSet       | TreeMap을 이용해서 구현                                                                                                  |
| LinkedHashMap | HashMap과 HashSet에 저장순서유지기능을 추가                                                                              |
| LinkedHashSet | -                                                                                                                        |
