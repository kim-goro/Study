> [목차](index.md)

## 14. 람다식

- [람다식](#람다식)
- [Functinal Interface](#Functinal-Interface)
- [java.util.function패키지](#java.util.function패키지)
- [매개변수가 두 개인 함수형 인터페이스](#매개변수가-두-개인-함수형-인터페이스)
- [Predicate의 결합](#Predicate의-결합)
- [컬렉션 프레임웍과 함수형 인터페이스](#컬렉션-프레임웍과-함수형-인터페이스)
- [메서드 참조](#메서드-참조)
- [Stream](#Stream)
- [스트림 만들기\_파일과 빈 스트림](#스트림-만들기_파일과-빈-스트림)
- [스트림의 연산\_중간 연산](#스트림의-연산_중간-연산)
- [스트림의 연산\_최종 연산](#스트림의-연산_최종-연산)
- [Optional](#Optional)
- [Collect와 Collectors](#Collect와-Collectors)
- [스트림을 컬렉션, 배열로 변환](#스트림을-컬렉션,-배열로-변환)
- [스트림의 그룹화와 분할](#스트림의-그룹화와-분할)
- [스트림의 변환](#스트림의-변환)

<br><br>
<br><br>

# 람다식

- 람다식(Lambda expression) : 메서드를 하나의 식(expression)으로 표현한 것이다.
- 일반 메서드의 이름과 반환값이 없어지므로 람다식을 익명 함수(anonymouse function)이라고도 한다.
- 메서드의 매개변수로 전달되어지는 것이 가능하고, 메서드의 결과로 반환될 수도 있다. (메서드를 변수처럼 다룬다.)

<br>

## 람다식 작성하기

1. `int max(int a, itn b){ return a > b ? a : b; }`
2. `(int a, int b) -> { return a > b ? a : b; }`
3. `(int a, int b) -> a > b ? a : b`
4. `(a, b) -> a > b ? a : b`

- 매개변수가 하나뿐인 경우에는 괄호()를 생략할 수 있다. (단, 매개변수의 타입이 있으면 괄호()를 생략할 수 없다.)
  - `a -> a * a`
  - `int a -> a * a` Error
- 괄호{} 안의 문장이 하나일 때 괄호{}를 생략할 수 있다. 이 때, 문장의 끝에 ';'를 붙이지 않아야 한다. ( return문이 있을 경우 생략할 수 없다.)
  - `(String name, int i) -> { System.out.println(name+"="+i); }`
  - `(String name, int i) -> System.out.println(name+"="+i)`
  - `(int a, int b) -> return a > b ? a : b` Error
  
  <br>

## 람다식은 익명 함수? 익명 객체!

자바에서 모든 메서드는 클래스 내에 포함되어야 하는데, 람다식은 어떤 클래스에 포함되는 것일까? 지금까지
람다식이 메서드와 동등한 것처럼 설명해왔지만, 사실 람다식은 익명 클래스의 객체와 동등하다.

- `(int a, int b) -> a > b ? a : b`
- `New Object(){ int max(int a, int b){ return a > b ? a : b ; } }`

<br><br>
<br><br>

# Functinal Interface

```java
interface MyFunction{
  public abstact int max(int a, int b);
}

//위 인터페이스를 구현한 익명 클래스의 객체는 다음과 같이 생성할 수 있다.
Myfunction f = new MyFunction(){ public int max(int a, int b){ return a > b ? a : b; } };
int big = f.max(5,3); // 익명 객체의 메서드를 호출
```

- `Myfunction인터페이스`에 정의된 메서드 `max()`는 람다식 `(int a, int b) -> return a > b ? a : b`과 메서드의 선언부가 일치한다.

```java
Myfunction f = (int a, int b) -> a > b ? a : b; // 익명객체를 람다식으로 대체
```

이처럼 `Myfunction인터페이스`를 구현한 익명 객체를 람다식으로 대체 가능한 이유는,
람다식도 실제로는 익명 객체이고. `Myfunction인터페이스`를 구현한 익명 객체의 메서드 `max()`와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 떄문이다.
그래서 인터페이스를 통해 람다식을 다루기로 결정되었으며 이를 함수형 인터페이스(functinal Interface)라 한다.

- 함수형 인터페이스는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다.
- 그래야 람다식 인터페이스의 메서드와 1:1 매칭도기 떄문.

```java
@FuctionalInterface // 함수형 인터페이스로 정의
interface Myfunction{
  public abstact int max(int a, int b);
}
```

```java
@FunctionalInterface
interface MyFunction {
	void run();  // public abstract void run();
}

class Ex14_1 {
	static void execute(MyFunction f) { // 매개변수의 타입이 MyFunction인 메서드
		f.run();
	}

	static MyFunction getMyFunction() { // 반환 타입이 MyFunction인 메서드
		MyFunction f = () -> System.out.println("f3.run()");
		return f;
	}

	public static void main(String[] args) {
		// 람다식으로 MyFunction의 run()을   구현
    MyFunction f1 = ()-> System.out.println("f1.run()");

		MyFunction f2 = new MyFunction() {  // 익명클래스로 run()을 구현
			public void run() {   // public을 반드시 붙여야 함
				System.out.println("f2.run()");
			}
		};

		MyFunction f3 = getMyFunction();

		f1.run();
		f2.run();
		f3.run();

		execute(f1);
		execute( ()-> System.out.println("run()") );
	}
}
```

<br><br>
<br><br>

# java.util.function패키지

`java.util.function패키지`에 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해 놓았다.
가능하면 이 패키지의 인터페이스를 활용하는 것이 좋다. 그래야, 함수형 인터페이스에 정의된 메서드 이름도 통일되고,
재사용성이나 유지보수 측면에서도 좋다. 자주 쓰이는 가장 기본적인 함수형 인터페이스는 다음과 같다.

| 함수형 인터페이스  | 메서드            | 설명                                                             |
| :----------------- | :---------------- | :--------------------------------------------------------------- |
| java.lang.Runnable | void run()        | 매개변수도 없고, 반환값도 없음.                                  |
| Supplier<T>        | T get()           | 매개변수는 없고, 반환값만 있음.                                  |
| Consumer<T>        | void Accept(T t)  | Supplier와 반대로 매개변수만 있고, 반환값이 없음                 |
| Fuction<T,R>       | R apply(T t)      | 일반적인 함수, 하나의 매개변수를 받아서 결과를 반환              |
| Predicate<T>       | boolean test(T t) | 조건식을 표현하는데 사용됨, 매개변수는 하나, 반환 타입은 boolean |

- 매개변수와 반환값의 유무에 따라 4개의 함수형 인터페이스가 정의되어 있다.
- 타입 문자 `T`는 Type을, `R`은 Return Type을 의미한다.

<br><br>
<br><br>

# 매개변수가 두 개인 함수형 인터페이스

- 매개변수의 개수가 2개인 함수형 인터페이스는 이름 앞에 접두사 `Bi`가 붙는다.

| 함수형 인터페이스 | 메서드                 | 설명                                                        |
| :---------------- | :--------------------- | :---------------------------------------------------------- |
| BiConsumer<T,U>   | void accept(T t, U u)  | 두 개의 매개변수만 있고, 반환값이 없음                      |
| BiPredicate<T,U>  | boolean test(T t, U u) | 조건식을 표현하는데 사용됨, 매개변수는 둘, 반환값은 boolean |
| BiFunction<T,U,R> | R apply(T t, U u)      | 두 개의 매개변수를 받아서 하나의 결과를 반환                |

<br>
 
> #### UnaryOperator와 BinaryOperator
 
| 함수형 인터페이스 | 메서드 | 설명 |
| :------- | :------- | :------- |
| UnaryOperator<T> | T apply(T t) | Function의 자손, Function과 달리 매개변수와 결과의 타입이 같다. |
| BinaryOperator<T> | T apply(T t, T t) | BiFuction의 자손, BiFunction과 달리 매개변수와 결과의 타입이 같다. |

```java
import java.util.function.*;
import java.util.*;

class Ex14_2 {
	public static void main(String[] args) {
		Supplier<Integer>  s = ()-> (int)(Math.random()*100)+1;
		Consumer<Integer>  c = i -> System.out.print(i+", ");
		Predicate<Integer> p = i -> i%2==0;
		Function<Integer, Integer> f = i -> i/10*10; // i의 일의 자리를 없앤다.

		List<Integer> list = new ArrayList<>();
		makeRandomList(s, list);
		System.out.println(list);
		printEvenNum(p, c, list);
		List<Integer> newList = doSomething(f, list);
		System.out.println(newList);
	}

	static <T> List<T> doSomething(Function<T, T> f, List<T> list) {
		List<T> newList = new ArrayList<T>(list.size());

		for(T i : list) {
			newList.add(f.apply(i));
		}

		return newList;
	}

	static <T> void printEvenNum(Predicate<T> p, Consumer<T> c, List<T> list) {
		System.out.print("[");
		for(T i : list) {
			if(p.test(i))
				c.accept(i);
		}
		System.out.println("]");
	}

	static <T> void makeRandomList(Supplier<T> s, List<T> list) {
		for(int i=0;i<10;i++) {
			list.add(s.get());
		}
	}
}
```

<br><br>
<br><br>

# Predicate의 결합

- 여러 조건식을 논리 연산자인 `&&(and)`, `||(or)`, `!(not)`으로 연결해서 하나의 식을 구성할 수 있는 것처럼, 여러 `Predicate`를 `and()`, `or()`, `negate()`로 연결해서 하나의 새로운 `Predicate`로 결합할 수 있다.

```java
Predicate<Integer> p = i -> i < 100;
Predicate<Integer> q = i -> i < 200;
Predicate<Integer> r = i -> i%2 == 0;
Predicate<Integer> notP = P.negate();

//100 <= i && (i < 200 || i%2==0)
Predicate<Integer> all = notP.and(q.or(r));
System.out.println(all.test(150); // true

//여러 조건식을 하나로 합칠 수 있다.
Predicate<Integer> all = notP.and(i -> i < 200).or(i -> i%2 == 0);

//static메서드인 isEqual()은 두 대상을 비교하는 Rredicate를 만들 때 사용한다.
Predicate<String> p = Predicate.isEqual(str1);
boolean reuslt1 = p.test(str2);
boolean result2 = Predicate.isEqual(str1).test(str2); //'test()' 같은지 비교
```

```java
import java.util.function.*;

class Ex14_3 {
public static void main(String[] args) {
	Function<String, Integer>	f  = (s) -> Integer.parseInt(s, 16);
	Function<Integer, String>	g  = (i) -> Integer.toBinaryString(i);

	Function<String, String>    h  = f.andThen(g);
	Function<Integer, Integer>  h2 = f.compose(g);

	System.out.println(h.apply("FF")); // "FF" -> 255 -> "11111111"
	System.out.println(h2.apply(2));   // 2 -> "10" -> 16

	Function<String, String> f2 = x -> x; // 항등 함수(identity function)
	System.out.println(f2.apply("AAA"));  // AAA가 그대로 출력됨

	Predicate<Integer> p = i -> i < 100;
	Predicate<Integer> q = i -> i < 200;
	Predicate<Integer> r = i -> i%2 == 0;
	Predicate<Integer> notP = p.negate(); // i >= 100

	Predicate<Integer> all = notP.and(q.or(r));
	System.out.println(all.test(150));       // true

	String str1 = "abc";
	String str2 = "abc";

	// str1과 str2가 같은지 비교한 결과를 반환
	Predicate<String> p2 = Predicate.isEqual(str1);
	boolean result = p2.test(str2);
	System.out.println(result);
}
}
```

<br><br>
<br><br>

# 컬렉션 프레임웍과 함수형 인터페이스

컬렉션 프레임웍의 인터페이스에 다수의 디폴트 메서드가 추가되었는데, 그 중의 일부는 함수형 인터페이스를 사용한다.
| 인터페이스 | 메서드 | 설명 |
| :------- | :------- | :------ |
| Collection | boolean removeit(Predicate<E> filter) | 조건에 맞는 요소를 삭제 |
| List | void replaceAll(UnaryOperator<E> operator) | 모든 요소를 변환하여 대체 |
| Iterable | void forEach(Consumer<T> action) | 모든 요소에 작업 action을 수행 |
| Map | V compute(K key, BiFunction(K,V,V) f) | 지정된 키의 값에 작업 f를 수행 |
| Map | V computeIfAbsent(K key, Function<K,V> f) | 키가 없을면, 작업 f 수행 후 추가 |
| Map | V computeIfPresent(K key, BiFunction<K,V,V> f) | 지정된 키가 있을 때, 작업 f 수행 |
| Map | V merge(K Key, V value, BiFunction<V,V,V> f) | 모든 요소에 병합작업 f를 수행 |
| Map | void forEach(BiConsumer<K,V> action) | 모든 요소에 작업 action을 수행 |
| Map | void replaceAll(BiFunction<K,V,V> f) | 모든 요소에 치환작업 f를 수행 |

```java
import java.util.*;

class Ex14_4 {
	public static void main(String[] args) 	{
		ArrayList<Integer> list = new ArrayList<>();
		for(int i=0;i<10;i++)
			list.add(i);

		// list의 모든 요소를 출력
		list.forEach(i->System.out.print(i+","));
		System.out.println();

		// list에서 2 또는 3의 배수를 제거한다.
		list.removeIf(x-> x%2==0 || x%3==0);
		System.out.println(list);

		list.replaceAll(i->i*10); // list의 각 요소에 10을 곱한다.
		System.out.println(list);

		Map<String, String> map = new HashMap<>();
		map.put("1", "1");
		map.put("2", "2");
		map.put("3", "3");
		map.put("4", "4");

		// map의 모든 요소를 {k,v}의 형식으로 출력한다.
		map.forEach((k,v)-> System.out.print("{"+k+","+v+"},"));
		System.out.println();
	}
}
```

<br><br>
<br><br>

# 메서드 참조

- 람다식이 하나의 메서드만 호출하는 경우에는 메서드 참조(method reference)라는 방법으로 람다식을 간략히 할 수 있다.
- `클래스이름::메서드이름` 또는 `참조변수::메서드이름`으로 바꿀 수 있다. 
	1. `Function<String, Integer> f = (String) s -> Integer.parseInt(s);` 
	2. `Fcuntion<String, Integer> f = Integer::parseInt;` // 메서드 참조

| 종류                          | 람다                       | 메서드 참조       |
| :---------------------------- | :------------------------- | :---------------- |
| static메서드 참조             | (x) -> ClassName.method(x) | ClassName::method |
| 인스턴스메서드 참조           | (obj, x) -> obj.method(x)  | ClassName::method |
| 특정 객체 인스턴스메서드 참조 | (x) -> obj.method(x)       | obj::method       |

<br>

## 생성자의 메서드 참조

- 생성자를 호출하는 람다식도 메서드 참조를 변환할 수 있다.
- 람다식을 마치 static변수처럼 다룰 수 있게 해준다.

```java
Supplier<MyClass> s = () -> new MyClass(); // 람다식
Supplier<MyClass> s = MyClass::new; // 메서드 참조

//매개변수가 있는 생성자
Function<String, Integer> f = (i) -> new Myclass(i);
Function<String, Integer> f2 = Myclass::new;
BiFunction<Integer, String, MyClass> bf = (i, s) -> new MyClass(i, s);
BiFunction<Integer, String, MyClass> bf2 = MyClass::new;

//배열 생성시
Function<Integer, int[]> f = x -> new int[x]; // 람다식
Function<Integer, int[]> f2 = int[]::new; // 메서드 참조
```

<br><br>
<br><br>

# Stream

`Collection`이나 `Iterator`와 같은 인터페이스를 이용해서 컬렉션을 다루는 방식을 표준화하기는 했지만, 각 컬렉션 클래스에는
같은 기능의 메서드들이 중복해서 정의되어 있다. 예를 들어 `List`를 정렬할 때는 `Collections.sort()`를 사용해야하고,
배열을 정렬할 때는 `Arrays.sort()`를 사용해야 한다. 이러한 문제점들을 해결하기 위해 만든 것이 스트림이다.

- 스트림은 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해 놓았다. (데이터 소스가 어떤 타입이든 다룰 수 있다.)

```java
String[] strArr = {"aaa","ddd","ccc"};
List<String> strList = Arrays.asList(strArr);

Stream<String> strStream1 = strList.stream(); // 스트림을 생성
Stream<String> strStream2 = Arrays.stream(strArr); // 스트림을 생성

strStream1.sorted().forEach(System.out::println);
strStream2.sorted().forEach(System.out::println);
```

<br>

## 스트림의 특징

- 스트림은 데이터 소스를 변경하지 않는다. - 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다. - `List<String> sortedList = strStream2.sorted().collect(Collectors.toList());
- 스트림은 일회용이다.
- 스트림은 작업을 내부 반복으로 처리한다. - 내부반복 : 반복문을 메서드의 내부에 숨겼다는 것을 의미. - `foreach()`는 스트림에 정의된 메서드 중의 하나로 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용한다. 1. `for(String str : strList) System.out.println(str);` 2. `steam.forEach(System.out::println)`;
- 지연된 연산 : 최종 연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다.
- `Stream<Integer>`와 `IntStream` : 요소의 타입이 T인 스트림은 기본적으로 `Stream<T>`이지만, 오토박싱&언박싱으로 인한 비효율을 줄이기 위해
  데이터 소스의 요소를 기본형으로 다루는 스트림, `IntStream`, `LongStream`, `DoubleStream`이 제공된다.
- 병렬 스트림 : 내부적으로 Java에서 제공하는 fork&join프레임웍을 이용해서 자동적으로 연산을 병렬로 수행한다.
  우리가 할일이라고는 그저 스트림에 `parallel()`이라는 메서드를 호출해서 병렬로 연산을 수행하도록 지시하면될 뿐이다.
  반대로 병렬로 처리되지 않게 하려면 `sequential()`을 호출하면 된다. 모든 스트림은 기본적으로 병렬 스트림이 아니므로 `sequential()`을 호출할 필요가 없다.  
  <br>

> ### 스트림 만들기\_Collection

- 컬렉션의 최고 조상인 `Collection`에 `stream()이 정의되어 있다.
- `Collection`의 자손인 `List`와 `Set`을 구현한 컬렉션 클래스들은 모두 아래 메서드로 스트림을 생성할 수 있다. - `Stream<T> Collection.stream()`

```java
List<Integer> list = Arrays.asList(1,2,3,4,5); // 가변인자
Stream<Integer> intStream = list.stream(); // list를 소스로 하는 스트림 생성

//'foreach()'는 지정된 작업을 스트림의 모든 요소에 대해 수행한다.
intStream.forEach(System.out::println); // 스트림의 모든 요소를 출력한다.
intStream.forEach(System.out::println); // 에러, 스트림이 이미 닫혔다.
```

<br>

> ### 스트림 만들기\_Array

- 배열을 소스로 하는 스트림을 생성하는 메서드는 다음과 같이 `Stream`과 `Array`에 static메서드로 정의되어 있다. - `Stream<T> Stream.of(T... values)` : 가변 인자 - `Stream<T> Stream.of(T[])` - `Stream<T> Arrays.stream(T[])` - `Stream<T> Arrays.stream(T[] array, int startInclusive, int endExclusive)`
- `int`, `long`, `double`과 같은 기본형 배열을 소스로 하는 스트림을 생성하는 메서드도 있다. - `IntStream IntStream.of(int... values)` - `IntStream IntStream.of(int[])` - `IntStream Arrays.stream(int[])` - `IntStream Arrays.stream(int[] array, int startInclusive, int endExclusive)`

```java
//문자열 스트림
String<String> strStream = Stream.of("a","b","c"); // 가변 인자
String<String> strStream = Stream.of(new String[]{"a","b","c"});
String<String> strStream = Arrays.stream(new String[]{"a","b","c"});
String<String> strStream = Arrays.stream(new String[]{"a","b","c"},0,3);
```

<br>

> ### 스트림 만들기\_임의의 수

- 난수를 생성하는데 사용하는 `Random클래스`에는 아래와 같은 인스턴스 메서드들이 포함되어 있다. 
	- `IntStream ints()` : 무한 스트림 
	- `LongStream longs()` 
	- `DoubleStream doubles()`
- 무한 스트림(infinite stream)이므로 `limit()`도 같이 사용해서 스트림의 크기를 제한해 주어야 한다. 
	- `IntStream intStream = new Random().ints();` : 무한 스트림 
	- `IntStream.limit(5).forEach(System.out::println);` : 5개의 요소만 출력한다.
- 유한 스트림 - `IntStream ints(long streamSize)` 
	- `LongStream longs(long streamSize)` 
	- `DoubleStream doubles(long streamSize)` 
	- `IntStream intStream = new Random().int(5);` : 크기가 5인 난수 스트림을 반환
- 위 메서드들에 의해 생성된 스트림의 난수는 아래와 같은 범위를 갖는다. 
	- `Integer.MIN_VALUE` <= `ints()` <= `Integer.MAX_VALUE` 
	- `Long.MIN_VALUE` <= `longs()` <= `Long.MAX-VALUE` 
	- `0.0` <= `double()` < `1.0`  
  <br>

> ### 스트림 만들기\_특정 범위의 정수

- `IntStream`가 `LongStream`은 다음과 같이 지정된 범위의 연속된 정수를 스트림으로 생성해서 반환하는 `range()`와 `rangeClosed()`를 가지고 있다. 
	- `IntStream IntStream.range(int begin, int end)` 
	- `IntStream IntStream.rangeClose(int begin, int end)` : 끝 값 포함
- 지정된 범위(begin~end)의 난수를 발생시키는 스트림은 얻는 메서드 
	- `IntStream ints(int begin, int end)` 
	- `LongStream longs(long begin, long end)` 
	- `DoubleStream double(double begin, double end)` 
	- `IntStream ints(long streamSize, int begin, int end)` 
	- `LongStream longs(long streamSize, long begin, long end)` 
	- `DoubleStream doubles(long streamSize, double begin, double end)`  
  <br>

> ### 스트림 만들기\_람다식 interate, generate

- `Stream클래스`의 `iterate()`와 `generate()`는 람다식을 매개변수로 받아서, 이 람다식에 의해 계산되는 값들을 요소로 하는 무한 스트림을 생성한다. - `static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)` - `static <T> Stream<T> generate(Supplier<T> s)`
- `iterate()`는 씨앗값(seed)으로 지정된 값부터 시작해서, 람다식 f에 의해 계산된 결과를 다시 seed값으로 해서 계산을 반복한다.
- `generate()`도 마찬가지지만, 이전 결과를 이용해서 다음 요소를 계산하지 않는다. - 그리고 `generate()`에 정의된 매개변수의 타입은 `Supplier<T>`이므로 매개변수가 없는 람다식만 허용된다.

```java
//iterate
Stream<Integer> evenSteam = Steam.iterate(0,n->n+2); // 0, 2, 4, 6...

//generate
String<Double> randomStream = Stream.generate(Math::random);
Stream<Integer> oneStream = Stream.generate(()->1);

//iterate와 generate는 기본형 스트림 타입의 참조변수를 다룰 수 없다.
IntStream evenStream = Stream.iterate(0,n->n+2); // 에러
DoubleStream randomStream = Stream.generate(Math.random); // 에러

//굳이 필요하다면 'mapToInt()'와 같은 메서드로 변환해야 함
IntStream evenStream = Stream.iterate(0, n->n+2).mapToInt(Integer::valueOf);
Stream<Integer> stream = evenStream.boxed(); // IntStream -> Stream<Integer>
```

<br><br>
<br><br>

# 스트림 만들기\_파일과 빈 스트림

`java.nio.file.Files`는 파일을 다루는데 필요한 유용한 메서드들을 제공하는데, `list()`는 지정된 디렉토리(dir)에 있는 파일을 목록을 소스로 하는 스트림을 생성해서 반환한다.

- `Stream<String> Files.lines(Path path)` - `Stream<String> Files.lines(Path path, Charset cs)`

- `BufferedReader클래스`는 입력대상이나 파일의 한 행(line)을 요소로 하는 스트림을 생성한다. - `Stream<String> lines()`  
  <br>

## 빈 스트림

스트림의 연산을 수행한 결과가 하나도 없을 때, null보다 빈 스트림을 반환하는 것이 낫다.

```java
Stream emptyStream = Stream.empty(); // empty()는 빈 스트림을 생성해서 반환한다.
long count = emptyStream.count(); // count의 값은 0
```

<br>

## 스트림의 연산

- 스트림에 정의한 메서드 중에서 데이터 소스를 다루는 작업을 수행하는 것을 연산(operation)이라고 한다.
- 중간 연산 : 연산 결과가 스트림인 연산. 스트림에 연속해서 중간 연산할 수 있음
- 최종 연산 : 연산 결과가 스트림이 아닌 연산. 스트림의 요소를 소모하므로 단 한번만 가능

```java
stream.distinct().limit(5).sorted().forEach(System.out::println)
```

    - `distinct()` : 중간 연산
    - `limit(5)` : 중간 연산
    - `sorted()` : 중간 연산
    ` `forEach(System.out::println)` : 최종 연산

```java
String[] strArr = { "dd","aaa","CC","cc","b" };

Stream<String> stream = Stream.of(strArr); // 문자열 배열이 소스인 스트림
Stream<String> filteredStream = stream.filter(); // 걸러 내기(중간 연산)
Stream<String> distinctedStream = stream.distinct(); // 중복 제거(중간 연산)
Stream<String> sortedStream = stream.sort(); // 정렬(중간 연산)
Stream<String> limitedStream = stream.limit(5); // 스트림 자르기(중간 연산)
int total = stream.count(); // 요소 개수 세기(최종 연산)
```

<br><br>
<br><br>

# 스트림의 연산\_중간 연산

| 중간 연산                                  | 설명                                        |
| :----------------------------------------- | :------------------------------------------ |
| Stream<T> distinct()                       | 중복을 제거                                 |
| Stream<T> filter(Predicate<T> predicate)   | 조건에 안 맞는 요소를 제외                  |
| Stream<T> limit(long maxSize)              | 스트림의 일부를 잘라낸다.                   |
| Stream<T> skip(long n)                     | 스트림의 일부를 건너뛴다.                   |
| Stream<T> peek(Consumer<T> action)         | 스트림의 요소에 작업수행                    |
| Stream<T> sorted()                         | 스트림의 요소를 정렬한다                    |
| Stream<T> sorted(Comparator<T> comparator) | -                                           |
| Stream<R>                                  | map(Function<T,R> mapper                    | 스트림의 요소를 변환한다. |
| Stream<R>                                  | flatMap(Function<T,Stream<R>> mapper        | - |
| DoubleStream                               | mapToDouble(ToDoubleFunction<T> mapper)     | - |
| DoubleStream                               | flatMapToDouble(ToDoubleFunction<T> mapper) | - |
| IntStream                                  | mapToInt(ToIntFunction<T> mapper)           | - |
| IntStream                                  | flatMapToInt(ToIntFunction<T> mapper)       | - |
| LongStream                                 | mapToLong(ToLongFunction<T> mapper)         | - |
| LongStream                                 | flatMapToLong(ToLongFunction<T> mapper)     | - |

<br>

> #### 스트림의 중간연산\_skip, limit

- 스트림의 일부를 잘라낼 때 사용 
	- `Stream<T> skip(long n)` 
	- `Stream<T> limit(long maxSize)` 
	- `IntStream skip(long n)` 
	- `IntStream limi(long maxSize)`

```java
// skip : 요소를 건너뜀, limit : 요소를 제한함
IntStream intStream = IntStream.rangeClosed(1, 10); // 1~10의 요소를 가진 스트림
intStream.skip(3).limit(5).forEach(System.out::print); // 45678
```

<br>

> #### 스트림의 중간연산\_filter(), distinct()

- distinct()는 스트림에서 중복된 요소들을 제거하고, `filter()`는 주어진 조건(Predicate)에 맞지 않는 요소를 걸러낸다. 
	- `Stream<T> filter(Predicate<? super T> predicate)` 
	- `Stream<T> distinct()`

```java
//distinct
IntStream.intStream = IntStream.of(1,2,2,3,3,3,5,5,6);
IntStream.distinct().forEach(System.out::print); // 123456

//filter
IntStream intStream = IntStream.rangeClosed(1,10); // 1~10
instStream.filter(i -> i%2 ==0).forEach(System.out::print); // 246810
intStream.filter(i -> i%2 != 0 && i%3 != 0).forEach(System.out::print); // 157
intStream.filter(i -> i%2 != 0).filter(i -> i%3 != 0).forEach(System.out::print);
```

<br>

> #### 스트림의 중간연산\_sorted

- 스트림을 정렬할 때 
	- `Stream<T> sorted()` 
	- `Stream<T> sorted(Comparator<? super T> comparator)`
- `sorted()`는 지정된 `Comparator`로 스트림을 정렬하는데, `Comparator`대신 int값을 반환하는 람다식을 사용하는 것도 가능하다.
- `Comparator`를 지정하지 않으면 스트림 요소의 기본 정렬 기준(Comparable)로 정렬한다. 단, 스트림의 요소가 Comparable을 구현한 클래스가 아니면 예외가 발생한다.

```java
Stream<String> strStream = Stream.of("dd","aaa","CC","cc","b");
strStream.sorted().forEach(System.out::print); // CCaaabccdd -> 문자열 스트림 String에 정의된 기본 정렬(사전순 정렬)로 정렬해서 출력됨
```

| 문자열 스트림 정렬 방법                                         | 설명              | 출력결과   |
| :-------------------------------------------------------------- | :---------------- | :--------- |
| strStream.sorted()                                              | 기본 정렬         | CCaaabccdd |
| strStream.sorted(Comparator.natualOrder())                      | 기본 정렬         | -          |
| strStream.sorted((s1,s2) -> s1.compareTo(s2));                  | 람다식도 가능     | -          |
| strStream.sorted(String::compareTo);                            | 위의 문장과 동일  | -          |
| strStream.sorted(Comparator.reverseOrder())                     | 기본 정렬의 역순  | ddccbaaaCC |
| strStream.sorted(Comparator.<String>naturalOrder().reversed())  |                   | -          |
| strStream.sorted(String.CASE_INSENSITIVE_ORDER)                 | 대소문자 구분안함 | aaabCCccdd |
| strStream.sorted(String.CASE_INSENSITIVE_ORDER.reversed())      | 오타아님          | ddCCccbaaa |
| strStream.sorted(Comparator.comparing(String::length))          | 길이 순 정렬      | bddCCccaaa |
| strStream.sorted(Comparator.comparingInt(String::length))       | no오토박싱        | -          |
| strStream.sorted(Comparator.comparing(String::length).reversed) |                   | aaaddCCccb |

<br>

## 스트림의 중간연산\_Comparator의 메서드

- `Jdk1.8`부터 `Comparator인터페이스`에 static메서드와 디폴트 메서드가 추가되었다.
- 이 메서드들은 모두 `Comparator<T>`를 반환하며 이를 이용하면 정렬이 쉬워진다. 
	- `comparing(Fuction<T, Y> keyExtractor)` 
	- `comparing(Function<T, U> keyExtractor, Comparator<U> keyComparator)`

- 스트림의 요소가 `Comparable`을 구현하지 않은 경우, 추가적인 매개변수로 정렬기준(Comparator)을 따로 지정해 줘야한다. 
	- `comparingInt(ToIntFunction<T> keyExtractor)` 
	- `comparingLong(ToLongFunction<T> keyExtractor)` 
	- `comparingDouble(ToDoubleFuncion<T> keyExtractor)`
- 정렬조건을 추가할 때는 `thenComparing()`을 사용한다. 
	- `thenComparing(Comparator<T> other)` 
	- `thenComparing(Function<T, U> keyExtractor)` 
	- `thenComparing(Function<T, U> keyExtactor, Comparator<U> keyComp)`

```java
studentStream.sorted(Comparator.comparing(Student::getBan).thenComparing(Student::getTotalScore).thenComparing(Student.getName)).forEach(System.out::println);
```

```java
import java.util.*;
import java.util.stream.*;

class Ex14_5 {
	public static void main(String[] args) {
		Stream<Student> studentStream = Stream.of(
						new Student("이자바", 3, 300),
						new Student("김자바", 1, 200),
						new Student("안자바", 2, 100),
						new Student("박자바", 2, 150),
						new Student("소자바", 1, 200),
						new Student("나자바", 3, 290),
						new Student("감자바", 3, 180),
					);

		studentStream.sorted(Comparator.comparing(Student::getBan) // 반별 정렬
		 	.thenComparing(Comparator.naturalOrder()))     	//
			.forEach(System.out::println);
	}
}

class Student implements Comparable<Student> {
	String name;
	int ban;
	int totalScore;
	Student(String name, int ban, int totalScore) {
		this.name =name;
		this.ban =ban;
		this.totalScore =totalScore;
	}

	public String toString() {
	   return String.format("[%s, %d, %d]", name, ban, totalScore);
	}

	String getName()     { return name;}
	int getBan()         { return ban;}
	int getTotalScore()  { return totalScore;}

   // 총점 내림차순을 기본 정렬로 한다.
	public int compareTo(Student s) {
		return s.totalScore - this.totalScore;
	}
}
```

학생의 성적 정보를 요소로 하는 `Stream<Student>`을 반별로 정렬한 다음에, 총점별 내림차순으로 정렬한다.
정렬하는 코드를 짧게하려고, `Comparable`을 구현해서 총점별 내림차순 정렬이 `Student클래스`의 기본 절렬이 되도록 했다.  
<br>

> #### 스트림의 중간연산\_map
>
> 스트림의 요소에 저장된 값 중에서 원하는 필드만 뽑아내거나 특정 형태로 변환해야 할 때가 있다.
> 이 때 사용하는 것이 바로 map()이다. 이 메서드의 선언부는 아래와 같으며, 매개변수로 T타입을 R타입으로 변환해서 반환하는 함수를 지정해야 한다. - `Stream<R> map(Function<? super T, ? extends R> mapper)`

```java
//'map()'을 이용해서 File객체에서 String이름만 간단히 뽑아낼 수 있다.
Stream<File> fileStream = Stream.of(new File(new File("Ex1.java"), new File("Ex1"), new File("Ex1.bak"), new File("Ex2.java"), new File("Ex1.txt"));

//'map()'으로 Stream<File>을 Stream<String>을 변환
Stream<String> filenameStream = fileStream.map(File::getName);
filenameStream.forEach(System.out::println); // 스트림의 모든 파일이름을 출력

//중첩적용 가능
fileStream.map(File::getName) // Stream<File> -> Stream<String>
	.filter(s -> s.indexOf('.') != -1) // 확장자가 없는 것은 제외
	.map(s -> s.substring(s.indexOf('.') + 1) // Stream<String> -> Stream<String>
	.map(String::toUpperCase) // 모두 대문자로 변환
	.distinct() // 중복 제거
	.forEach(System.out::print); // JAVABAKTXT
```

```java
import java.io.*;
import java.util.stream.*;

class Ex14_6 {
	public static void main(String[] args) {
		File[] fileArr = { new File("Ex1.java"), new File("Ex1.bak"),
			new File("Ex2.java"), new File("Ex1"), new File("Ex1.txt")
		};

		Stream<File> fileStream = Stream.of(fileArr);

		// map()으로 Stream<File>을 Stream<String>으로 변환
		Stream<String> filenameStream = fileStream.map(File::getName);
		filenameStream.forEach(System.out::println); // 모든 파일의 이름을 출력

		fileStream = Stream.of(fileArr);  // 스트림을 다시 생성

		fileStream.map(File::getName)     // Stream<File> -> Stream<String>
			  .filter(s -> s.indexOf('.')!=-1)   // 확장자가 없는 것은 제외
			  .map(s -> s.substring(s.indexOf('.')+1)) // 확장자만 추출
			  .map(String::toUpperCase)     // 모두 대문자로 변환
			  .distinct()                   // 중복제거
			  .forEach(System.out::print);  // JAVABAKTXT

		System.out.println();
	}
}
```

<br>

> #### 스트림의 중간연산\_peek
>
> 연산과 연산 사이에 올바르게 처리되었는지 확인하고 싶다면, `peek()`을 사용하자. `forEach()`와 달리 스트림의 요소를
> 소모하지 않으므로 연산 사이에 여러 번 끼워 넣어도 문제가 되지 않는다.

```java

fileStream.map(File::getName) // Stream<File> -> Stream<String>
	.filter(s -> s.indexOf('.') != -1)
	.peek(s -> System.out.printf("filename = %s%n", s)) // 파일명을 출력한다.
	.map(s -> s.substring(s.indexOf('.') + 1) // 확장자만 추출
	.peek(s -> System.out.printf("extension = %s%n", s)) // 확장자를 출력한다.
	.forEach(System.out::print); // JAVABAKTXT
```

<br>

> ### 스트림의 중간연산\_flatMap
>
> 스트림의 타입이 `Stream<T[]>`인 경우, `Stream<T>`로 변환해야 작업이 더 편리할 때가 있다. 그럴 떄 `flatMap()`을 사용한다.

```java
Stream<String[]> strArrStrm = Stream.of(new String[]{"abc", "def", "ghi"}, new String[]{"ABC","GHI","JKLMN"});

//각 요소의 문자열들을 합쳐서 문자열이 요소인 스트림, 즉 `Stream<String>`으로 만드려면?
Stream<Stream<String>> strStrStrm = strArrStrm.map(Arrays::stream); // 예상과 달리 변환한 결과는 Strema<Stream<String>>이다.

//'map()' 대신에 'flatMap()'으로 변경
Stream<String> strStrm = StrArrStrm.flatMap(Arrays::stream);
```

```java
import java.util.*;
import java.util.stream.*;

class Ex14_7 {
	public static void main(String[] args) {
		Stream<String[]> strArrStrm = Stream.of(
			new String[]{"abc", "def", "jkl"},
			new String[]{"ABC", "GHI", "JKL"}
		);

//		Stream<Stream<String>> strStrmStrm = strArrStrm.map(Arrays::stream);
		Stream<String> strStrm = strArrStrm.flatMap(Arrays::stream);

		strStrm.map(String::toLowerCase)
			   .distinct()
			   .sorted()
			   .forEach(System.out::println);
		System.out.println();

		String[] lineArr = {
			"Believe or not It is true",
			"Do or do not There is no try",
		};

		Stream<String> lineStream = Arrays.stream(lineArr);
		lineStream.flatMap(line -> Stream.of(line.split(" +")))
			.map(String::toLowerCase)
			.distinct()
			.sorted()
			.forEach(System.out::println);
		System.out.println();
	}
}
```

<br><br>
<br><br>

# 스트림의 연산\_최종 연산

| 최종 연산                                                                              | 설명                                                                                                |
| :------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------- |
| void forEach(Consumer<? super T> action)                                               | 각 요소에 지정된 작업 수행                                                                          |
| void forEacnOrdered(Consumer<? super T> action)                                        | -                                                                                                   |
| long Count()                                                                           | 스트림의 요소의 개수 반환                                                                           |
| Optional<T> max(Comparator<? super T> Comparator)                                      | 스트림의 최대값/최소값을 반환                                                                       |
| Optional<T> min(Comparator<> super T> comparator)                                      | -                                                                                                   |
| Optional<T> findAny()                                                                  | 스트림의 요소 하나를 반환                                                                           |
| Optional<T> FindFirst()                                                                | -                                                                                                   |
| boolean allMatch(Predicate<T> p)                                                       | 주어진 조건을 모든 요소가 만족시키는지, 만족시키지 않는지 확인                                      |
| boolean anyMatch(Predicate<T> p)                                                       | -                                                                                                   |
| boolean noneMatch(Predicate<T> p)                                                      | -                                                                                                   |
| Object[] toArray()                                                                     | 스트림의 모든 요소를 배열로 반환                                                                    |
| A[] toArray(IntFunction<A[]> generator)                                                | -                                                                                                   |
| Optional<T> reduce(BinaryOperator<T>, accumulator)                                     | 스트림의 요소를 하나씩 줄어가면서(리듀싱) 계산한다.                                                 |
| T reduce(T identity, BinaryOperator<T> accumulator)                                    | -                                                                                                   |
| U reduce(U identity, BiFunction<U,T,U> accumlator, BinaryOperator<U> combiner)         | -                                                                                                   |
| R collect(Collector<T,A,R> collector)                                                  | 스트림의 요소를 수집한다. 주로 요소를 그룹화하거나 분할한 결과를 컬렉션에 담아 반환하는데 사용한다. |
| R collect(Supplier<R> supplier, BiConsumer<R,T> accumulator, BiConsumer<R,R> combiner) | -                                                                                                   |

<br>

> #### 스트림의 최종연산\_forEach
>
> 최종 연산은 스트림의 요소를 소모해서 결과를 만들어 낸다. 그래서 최종 연산후에 스트림은
> 닫히게 되고 더 이상 사용할 수 없다. 최종 연산의 결과는 스트림 요소의 합과 같은 단일 값이거나,
> 스트림의 요소가 담긴 배열 또는 컬렉션일 수 있다.

- `forEach()`는 `peek()`와 달리 스트림의 요소를 소모하는 최종연산이다. 스트림의 요소를 출력하는 용도로 많이 사용된다. - `void forEach(Consumer<? super T> action)`  
  <br>

> #### 스트림의 최종연산\_조건검사

- 스트림의 요소에 대해 지정된 조건을 확인하는데 사용하는 메서드이다. 
	- `boolean allMatch (Predicate<? super T> predicate)` : 모든 요소가 일치하면 참 
	- `boolean anyMatch (Predicate<? super T> predicate)` : 하나의 요소라도 일치하면 참 
	- `boolean noneMatch (Predicate<? super T> predicate` : 모든 요소가 불일치하면 참

```java
// 학생들의 성적 정보 스트림 `stuStream`에서 총점이 낙제점(총점 100이하)인 학생이 있는지 확인하는 방법은 다음과 같다.
boolean noFailed = stuStream.anyMatch(s -> s.getTotalScore() <= 100);
```

이외에도 스트림의 요소 중에서 조건에 일치하는 첫 번째 것을 반환하는 `findFirst()`가 있는데, 주로 `filter()`와 함께 사용되어 조건에 맞는 스트림의
요소가 있는지 확인하는데 사용된다. 병렬스트림인 경우에는 `findFirst()`대신 `findAny()`를 사용해야 한다.

- `Optional<T> findFirst()` : 조건에 일치하는 첫 번째 요소를 반환 - `Optional<T> findAny()` : 조건에 일치하는 요소를 하나 반환(병렬 스트림)

```java
//`findAny()`와 `findFirst()`의 반환 타입은 `Optional<T>이며, 스트림의 요소가 없을 때는 비어있는 `Optional`객체를 반환한다.
// 비어있는 `Optional`객체는 내부적으로 null을 저장하고 있다.
Optional<Student> stu = stuStream.filter(s -> s.getTotalScore() <= 100).findFirst();
Optional<Student> stu = parallelStream.filter(s -> s.getTotalScore() <= 100).findAny();
```

<br>

> #### 스트림의 최종 연산\_reduce

- `reduce()` : 스트림의 요소를 줄여나가면서 연산을 수행하고 최종결과를 반환한다. 
- `Optional<T> reduce(BinaryOperator<T> accumulator)`  
- `BinaryOperator<T>`는 `BiFunction`의 자손이며, `BiFunction`<T,T,T>와 동등하다. 
	- `T reduce(T identity, BinaryOperator<T> accumulator)` 
	- `U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator(U) combiner)` : 병렬 스트림에 처리된 결과를 합침

>:grey_question: 이 외에도 연산결과의 초기값(identity)을 갖는 `reduce()`도 있는데, 이 메서드들은 초기값과
  스트림의 첫 번째 요소로 연산을 시작한다. 스트림의 요소가 하나도 없는 경우, 초기값이 반환되므로,
  반환 타입이 `Optional<T>`가 아니라 T이다.

```java
int count = intStream.reduce(0, (a,b) -> a + 1);
int sum = intStream.reduce(0, (a,b) -> a + b);
int max = intStream.reduce(Integer.MIN_VALUE,(a,b) -> a>b ? a:b);
int min = intStream.reduce(Integer.MAX_VALUE,(a,b) -> a<b ? a:b);
```

```java
//`reduce()`의 이해1
int a = identity // 초기값을 a에 저장한다.
for(int b : stream) a = a + b; // 모든 요소의 값을 a에 누적한다.

//`reduce()`의 이해2
T reduce(T identity, BinaryOperator<T> accumulator){
	T a = identity;
	for(T b : stream) a = accumulator.apply(a,b);
	return a;
}
```

<br><br>
<br><br>

# Optional

- `java.util.Optional`은 `JDK1.8`부터 추가되었다.
- `Optional<T>`는 'T타입의 객체'를 감싸는 래퍼 클래스이다.

```java
public final class Optional<T>{
	private final T value; // T타입의 참조변수
}
```

- `Optional객체`에 담아서 반환을 하면, 매번 if문으로 null체크를 하는 대신 `Optional`에 정의된 메서드를 통해서 간단히 처리할 수 있다.
- `NullPointerException`이 발생하지 않음으로 더욱 안전한 코드를 작성하는 것이 가능하다.  
  <br>

## Optional 객체 생성하기

```java
String str = "abc";
Optional<String> optVal = Optional.of(str);
Optional<String> optVal = Optional.of("abc");
Optional<String> optVal = Optional.of(new String("abc"));

//만일 참조변수의 값이 null일 가능성이 있으면, 'of()'대신에 'ofNUllable()'을 사용해야한다.
//'of()'는 매개변수의 값이 null이면 NullPointerException이 발생하기 때문이다./
Optional<String> optVal = Optional.of(null); // NullPointerException발생
Optional<String> optVal = Optional.ofNullable(null); // OK

//Optional<T>타입의 참조변수를 기본값으로 초기화할 때는 'empty()'를 사용한다.
Optional<String> optVal = null // 권장하지 않음
Optional<String> optVal = Optional.<String>empty(); // 빈 객체로 초기화
```

<br>

## Optional 객체의 값 가져오기

```java
Optional<String> optVal = Optional.of("abc");
String str1 = optVal.get(); // optVal에 저장된 값을 반환, null이면 예외발생
String str2 = optVal.orElse(""); // optVal에 저장된 값이 null일 때는, ""를 반환
```

- `orElse()`의 변형으로는 null을 대체할 값을 반환하는 람다식을 지정할 수 있는 `orElseGet()`과 null일 떄 지정된 예외를 발생시키는 `orElseThrow()`가 있다. 
	- `T orElseGet(Supplier<? extends T> other)` 
	- `T orElseThrow(Supplier<? extends X> exceptionSupplier)`

```java
String str3 = optVal2.orElseGet(String::new); // () -> new String()와 동일
String str4 = optVal2.orElseThrow(NullPointerException::new); // null이면 예외 발생
```

- `isPresent()`는 `Optional객체`의 값이 null이면 false를, 아니면 true를 반환한다. - `ifPresent(Consumer<T> block)` : 값이 있으면 주어진 람다식을 실행하고, 없으면 아무 일도 하지 않는다.

```java
if(str != null){ System.out.println(str); }

if(Optional.ofNullable(str).isPresent()){ System.out.println(str); }

Optional.ofNullable(str).ifPresent(System.out::println); // 참조변수'str'이 null이 아닐 때만 값을 출력한다.
```

<br>

> #### OptionalInt, OptionalLong, OptionalDouble

- `IntStream`과 같은 기본형 최종 연산의 일부는 `Optional`대신 기본형을 값으로 하는 `OptionalInt`, `OptionalLong`, `OptionalDouble`을 반환한다. 
	- `OptionalInt findAny()` 
	- `OptionalInt findFirst()` 
	- `OptionalInt reduce(IntBinaryOperator op)` 
	- `OptionalInt max()` 
	- `OptionalInt min()` 
	- `OptionalDouble average()`
- `Optional<T>`와 값을 꺼낼 떄의 차이

| Optional클래스 | 값을 반환하는 메서드 |
| :------------- | :------------------- |
| Optional<T>    | T get()              |
| OptionalInt    | int getAsInt()       |
| OptionalLong   | long getAsLong()     |
| OptionalDouble | double getAsDouble() |

```java
public final class OptionalInt{
	private final boolean isPresent; // 값이 저장되어 있으면 true
	private final int value; // int타입의 변수
	...
}

OptionalInt opt = OptionalInt.of(0); // OptionalInt에 0을 저장 (int의 기본값)
OptionalInt opt = OptionalInt.empty(); // OptionalInt에 0을 저장

//'isPresent'라는 인스턴스 변수로 구분이 가능하다. 'isPresent()'는 이 인스턴스변수의 값을 반환한다.
System.out.println(opt.isPresent()); // true
System.out.println(opt2.isPresent()); // false
System.out.println(opt.equals(opt2)); // false
```

<br><br>
<br><br>

# Collect와 Collectors

- `collect()`가 스트림의 요소를 수집하기 전에, 어떻게 수집할 것인가에 대한 방법을 정의한 것이 컬렉터(collector)이다.
- `collect()` : 스트림의 최종연산, 매개변수가 `Collector`을 구현한 클래스의 객체를 받는다. 
	- `Object collect(Collector collector)` 
	- `Object collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner)`
- `Collector` : 인터페이스. 컬렉터는 이 인터페이스를 구현해야 한다.
- `Collectors` : 클래스. static메서드로 미리 작성된 컬렉터를 제공한다.  
  <br><br>
  <br><br>

# 스트림을 컬렉션, 배열로 변환

## 스트림의 모든 요소를 컬렉션에 수집하는 방법

1. `Collector클래스`의 `toList()`와 같은 메서드를 사용

```java
List<String> names = stuStream.map(Student::getName).collect(Collectors.toList());
```

2. `List`나 `Set`이 아닌 특정 컬렉션을 지정하려면, toCollection()에 원하는 컬렉션의 생성자 참조를 매개변수로 넣어주면 된다.

```java
ArrayList<String> list = names.stream().collect(Collectors.toCollection(ArrayList:new));
```

3. `Map`은 키와 값의 쌍으로 저장해야하므로 객체의 어떤 필드를 키로 사용할지와 값으로 사용할지를 지정해줘야 한다.

```java
Map<String.Person> map = personStream.collect(Collectors.toMap(p -> p.getRegId(), p -> p));
```

4. 스트림에 저장된 요소들을 `T[]`타입의 배열로 전환하려면, `toArray()`를 사용하면 된다. 단, 해당 타입의 생성자 참조를 매개변수로 지정해줘야 한다.

```java
Student[] stuNames = studentStream.toArray(Student[]::new); // OK
Student[] stuNames = studentStream,toArray();
Object[] stuNames = studentStream.toArray();
```

<br>

> #### 스트림의 통계\_counting, summingInt

- `collect()`와 같은 결과를 얻을 수 있다. (`groupingBy()`와 함께 사용할 수 있다.)

```java
static import Collectors;

long count = stuStream.count();
long count = stuStream.collect(counting());

long totalScore = stuStream.mapToInt(Stduent::getTotalScore).sum();
long totalScore = stuStream.collect(summingInt(Student::getTotalScore));

Optional<Student> topStudent = stuStream.max(Comparator.comparingInt(Student::getTotalScore));
Optional<Student> topStudent = stuStream.collect(maxBy(Comparator.comparingInt(Student::getTotalScore)));

IntSummaryStatistics stat = stuStream.mapToInt(Student::getTotalScore).summaryStatistics();
IntSummaryStatistics stat = stuStream.collect(summarizingInt(Student::getTotalScore));
```

<br>

> #### 스트림을 리듀싱\_reducing

- `Collectors.reducing()`에는 아래와 같이 3가지 종류가 있다. (와일드 카드를 제거하여 간략히한 것이다.) 
	- `Collector reducing(BinaryOperator<T> op)` 
	- `Collector reducing(T identity, BinaryOperator<T> op)` 
	- `Collector reducing(U identity, Function<T,U> mapper, BinaryOperator<U> op)`  

리듀싱 역시 `collect()`가능하다.로 `IntStream`에는 매개변수 3개짜리 `collect()`만 정의되어 있으므로 `boxed()`를 통해 `IntStream`을
  `Stream<Integer>`로 변환해야 매개변수 1개짜리 `collect()`로 쓸 수 있다.

```java
IntStream intStream = new Random().ints(1,46).distinct().limit(6);

OptionalInt max = intStream.reduce(Integer::max);
Optional<Integer> max = intStream.boxed().collect(reducing(Integer::max));

long sum = intStream.reduce(0, (a,b) -> a + b );
long sum = intStream.boxed().collect(reducing(0, (a,b) -> a + b ));
int grandTotal = stuStream.map(Student::getTotalScore)).reduce(0, Integer::sum);
int grandTotal = stuStream.collect(reducing(0,Student::getTotalScore, Integer::sum));
```

<br>

> #### 스트림을 문자열로 결합\_joining

`joining()`은 문자열 스트림의 모든 요소를 하나의 문자열로 연결해서 반환한다.
구분자를 지정해줄 수도 있고, 접두사와 접비사도 지정가능하다. 스트림의 요소가 String이나
StringBuffer처럼 CharSequence의 자손인 경우에만 결합이 가능하므로 스트림의 요소가
문자열이 아닌 경우에는 먼저 `map()`을 이용해서 스트림의 요소를 문자열로 변환해야 한다.

```java
String studentNames = stuStream.map(Stduent::getName).collect(joining());
String studentNames = stuStream.map(Stduent::getName).collect(joining(","));
String studentNames = stuStream.map(Stduent::getName).collect(joining(",", "[", "]"));

// 만일 `map()`없이 스트림에 바로 `joining()`하면, 스트림의 요소에 `toString()`을 호출한 결과를 결합한다.
String studentInfo = stuStream.collect(joining(","));
```

<br><br>
<br><br>

# 스트림의 그룹화와 분할

그룹화는 스트림의 요소를 특정 기준으로 그룹화하는 것을 의미하고, 분할을 스트림의 요소를 두 가지,
지정된 조건에 일치하는 그룹과 일치하지 않는 그룹으로의 분할을 의미한다. 아래의 메서드 정의에서 알 수 있듯이,
`groupingBy()`는 스트림의 요소를 Function으로, `partitioningBy()`는 Predicate로 분류한다.

- `Collector partitioningBy(Predicate predicate)` 
- `Collector partitioningBy(Predicate predicate, Collector downstream)` 
- `Collector groupingBy(Function classifier)` 
- `Collector groupingBy(Function classifier, Cellector downstream)` 
- `Collector groupingBy(Function classifier, Supplier mapFactory, Collector downstream)`

스트림을 두 개의 그룹으로 나눠야 한다면, 당연히 `partitioningBy()`로 분할하는 것이 더 빠르다. 그 외에는 `groupingBy()`를 쓰면 된다.

```java
import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import static java.util.stream.Collectors.*;
import static java.util.Comparator.*;

class Student2 {
	String name;
	boolean isMale; // 성별
	int hak;        // 학년
	int ban;        // 반
	int score;

	Student2(String name, boolean isMale, int hak, int ban, int score) {
		this.name	= name;
		this.isMale	= isMale;
		this.hak	= hak;
		this.ban	= ban;
		this.score  = score;
	}
	String	getName()    { return name;	}
	boolean  isMale()     { return isMale;	}
	int      getHak()     { return hak;	}
	int      getBan()     { return ban;	}
	int      getScore()   { return score;	}

	public String toString() {
		return String.format("[%s, %s, %d학년 %d반, %3d점]",
			name, isMale ? "남":"여", hak, ban, score);
	}
   	// groupingBy()에서 사용
	enum Level { HIGH, MID, LOW }  // 성적을 상, 중, 하 세 단계로 분류
}

class Ex14_10 {
	public static void main(String[] args) {
		Student2[] stuArr = {
			new Student2("나자바", true,  1, 1, 300),
			new Student2("김지미", false, 1, 1, 250),
			new Student2("김자바", true,  1, 1, 200),
			new Student2("이지미", false, 1, 2, 150),
			new Student2("남자바", true,  1, 2, 100),
			new Student2("안지미", false, 1, 2,  50),
			new Student2("황지미", false, 1, 3, 100),
			new Student2("강지미", false, 1, 3, 150),
			new Student2("이자바", true,  1, 3, 200),
			new Student2("나자바", true,  2, 1, 300),
			new Student2("김지미", false, 2, 1, 250),
			new Student2("김자바", true,  2, 1, 200),
			new Student2("이지미", false, 2, 2, 150),
			new Student2("남자바", true,  2, 2, 100),
			new Student2("안지미", false, 2, 2,  50),
			new Student2("황지미", false, 2, 3, 100),
			new Student2("강지미", false, 2, 3, 150),
			new Student2("이자바", true,  2, 3, 200)
		};

		System.out.printf("1. 단순분할(성별로 분할)%n");
		Map<Boolean, List<Student2>> stuBySex =  Stream.of(stuArr)
				.collect(partitioningBy(Student2::isMale));

		List<Student2> maleStudent   = stuBySex.get(true);
		List<Student2> femaleStudent = stuBySex.get(false);

		for(Student2 s : maleStudent)   System.out.println(s);
		for(Student2 s : femaleStudent) System.out.println(s);

		System.out.printf("%n2. 단순분할 + 통계(성별 학생 수)%n");
		Map<Boolean, Long> stuNumBySex = Stream.of(stuArr)
				.collect(partitioningBy(Student2::isMale, counting())); // 학생 수 구하기

		// Map<Boolean, Long> stuNumBySex = Stream.of(stuArr)
				.collect(partitioningBy(Student2::isMale, summingLong())); // `summingLong`로 총점구하기

		System.out.println("남학생 수 :"+ stuNumBySex.get(true));
		System.out.println("여학생 수 :"+ stuNumBySex.get(false));

		System.out.printf("%n3. 단순분할 + 통계(성별 1등)%n");
		Map<Boolean, Optional<Student2>> topScoreBySex = Stream.of(stuArr)
				.collect(partitioningBy(Student2::isMale,
					maxBy(comparingInt(Student2::getScore))  // `collect`로 총점 구하기
				));
		System.out.println("남학생 1등 :"+ topScoreBySex.get(true));
		System.out.println("여학생 1등 :"+ topScoreBySex.get(false));

		Map<Boolean, Student2> topScoreBySex2 = Stream.of(stuArr)
			.collect(partitioningBy(Student2::isMale,
				collectingAndThen(
					maxBy(comparingInt(Student2::getScore)), Optional::get
				) // `maxBy()`는 반환타입이 `Optional<Student>임으로, `Student`로 얻기위해 `CollectingAndThen(..., Optinal::get)을 사용하면 된다.
			));

		System.out.println("남학생 1등 :"+ topScoreBySex2.get(true));
		System.out.println("여학생 1등 :"+ topScoreBySex2.get(false));

		System.out.printf("%n4. 다중분할(성별 불합격자, 100점 이하)%n");

		Map<Boolean, Map<Boolean, List<Student2>>> failedStuBySex =
			Stream.of(stuArr).collect(partitioningBy(Student2::isMale,
				partitioningBy(s -> s.getScore() <= 100))
			);
		List<Student2> failedMaleStu   = failedStuBySex.get(true).get(true);
		List<Student2> failedFemaleStu = failedStuBySex.get(false).get(true);

		for(Student2 s : failedMaleStu)   System.out.println(s);
		for(Student2 s : failedFemaleStu) System.out.println(s);
	}
}

```

> #### 스트림의 그룹화\_groupingBy()

```java
//stuStream을 반 별로 그룹지어 `Map`에 저장하는 방법
Map<Integer, List<Student>> stuByBan = stuStream.collect(groupingBy(Student::getBan)); // `toList()`가 생략됨

//`groupingBy()`로 그룹화를 하면 기본적으로 `List<T>`에 담는다.
Map<Integer, List<Student>> stuByBan = stuStream.collect(groupingBy(Student::getBan, toList())); // `toList()`가 생략됨
Map<Integer, HashSet(Student>> stuByHak = stuStream.collect(groupingBy(Student::getHak, toCollection(HashSet:new)));

//모든 학생의 세 등급(HIGH, MID, LOW)으로 분류하여 집계한다.
Map<Student.Level, Long> stuByLevel = stuStream.collect(groupingBy(s -> { if(s.getScore() >= 200) else if(s.getScore() >= 100) else }, counting()) }; // [MID] - 8 명, [HIGH] - 8명, [LOW] - 2명

//`groupingBy()`를 여러 번 사용하면, 다수준 그룹화가 가능하다. 만일 학년별로 그룹화 한 후에 다시 반별로 그룹화
Map<Integer, Map<Integer, List<Stduent>>> stuByHakAndBan = stuStream
	.collect(groupingBy(Student::getHak // 학년별 그룹화
		, groupingBy(Student::getBan) // 반별 그룹화
	));

//각 반의 1등을 출력
Map<Integer, Map<Integer, Student>> topStuByHakAndBan = stuStream.collect(groupingBy(Student::getHak, groupingBy(Student::getBan,
		collectingAndThen(max(comparingInt(Student::getScore)), Optional::get))));

//학년별과 반별로 그룹화한 다음에, 성적그룹으로 변환(mapping)하여, Set에 저장한다.
Map<Integer, Map<Integer, Set<Student.Level>>> stuByHakAndBan = stuStream.collect(
		groupingBy(Student::getHak, groupingBy(Student::getBan,
		mapping(s -> {if(s.getScore() >= 200) retrun Student.Level.HIGH;
		else if(s.getScore() >= 100) return Student.Level.MID;
		else}.toSet()))));
```

<br><br>
<br><br>

# 스트림의 변환

> ### 1. 스트림 -> 기본형 스트림

| from      | to           | 변환 메서드                             |
| :-------- | :----------- | :-------------------------------------- |
| Stream<T> | IntStream    | mapToInt(ToIntFunction<T> mapper)       |
| Stream<T> | LongStream   | mapToLong(ToLongFunction<T> mapper)     |
| Stream<T> | DoubleStream | mapToDouble(ToDoubleFunction<T> mapper) |

> ### 2. 기본형 스트림 -> 스트림

| from            | to              | 변환 메서드                     |
| :-------------- | :-------------- | :------------------------------ |
| IntStream<T>    | Stream<Integer> | boxed()                         |
| LongStream<T>   | Stream<Long>    | boxed()                         |
| DoubleStream<T> | Stream<Double>  | boxed()                         |
| IntStream<T>    | Stream<U>       | mapToInt(IntFunction<T> mapper) |

> ### 3. 기본형 스트림 -> 기본형 스트림

| from      | to           | 변환 메서드      |
| :-------- | :----------- | :--------------- |
| IntStream | LongStream   | asLongStream()   |
| IntStream | DoubleStream | asDoubleStream() |

> ### 4. 스트림 -> 부분 스트림

| from      | to        | 변환 메서드         |
| :-------- | :-------- | :------------------ |
| Stream<T> | Stream<T> | skip(long n)        |
| IntStream | IntStream | limit(long maxSize) |

> ### 5. 두 개의 스트림 -> 스트림

| from                       | to           | 변환 메서드                            |
| :------------------------- | :----------- | :------------------------------------- |
| Stream<T>, Stream<T>       | Stream<T>    | concat(Stream<T> a, Stream<T> b)       |
| IntStream, IntStream       | IntStream    | concat(IntStream a, IntStream b)       |
| LongStream, LongStream     | LongStream   | concat(LongStream a, LongStream b)     |
| DoubleStream, DoubleStream | DoubleStream | concat(DobuleStream a, DoubleStream b) |

> ### 6. 스트림의 스트림 -> 스트림

| from                 | to           | 변환 메서드                      |
| :------------------- | :----------- | :------------------------------- |
| Stream<Stream<T>>    | Stream<T>    | flatMap(Function mapper)         |
| Stream<IntStream>    | IntStream    | flatMapToInt(Function mapper)    |
| Stream<LongStream>   | LongStream   | flatMapToLong(Function mapper)   |
| Stream<DoubleStream> | DoubleStream | flatMapToDouble(Function mapper) |

> ### 7. 스트림 -> 병렬 스트림

| from         | to           | 변환 메서드                                                                |
| :----------- | :----------- | :------------------------------------------------------------------------- |
| Stream<T>    | Stream<T>    | Parallel() // 스트림 -> 병렬스트림, sequentialal() // 병렬스트림 -> 스트림 |
| IntStream    | IntStream    | Parallel() // 스트림 -> 병렬스트림, sequentialal() // 병렬스트림 -> 스트림 |
| LongStream   | LongStream   | Parallel() // 스트림 -> 병렬스트림, sequentialal() // 병렬스트림 -> 스트림 |
| DoubleStream | DoubleStream | Parallel() // 스트림 -> 병렬스트림, sequentialal() // 병렬스트림 -> 스트림 |

> ### 8. 스트림 -> 컬렉션

| from                                           | to            | 변환 메서드                                        |
| :--------------------------------------------- | :------------ | :------------------------------------------------- |
| Stream<T>, IntStream, LongStream, DoubleStream | Collection<T> | collect(Collectors.toCollection(Supplier factory)) |
| -                                              | List<T>       | collect(Collectors.toList())                       |
| -                                              | Set<T>        | collect(Collectors.toSet())                        |

> ### 9. 컬렉션 -> 스트림

| from                           | to        | 변환 메서드 |
| :----------------------------- | :-------- | :---------- |
| Collection<T>, List<T>, Set<T> | Stream<T> | stream()    |

> ### 10. 스트림 -> Map

| from         | to       | 변환 메서드                                                                                   |
| :----------- | :------- | :-------------------------------------------------------------------------------------------- |
| Stream<T>    | map<K,V> | collect(Collectors.toMap(Function key, Function value))                                       |
| IntStream    | map<K,V> | collect(Collectors.toMap(Function k, Function v, BinaryOperator))                             |
| LongStream   | map<K,V> | collect(Collectors.toMap(Function k, Function v, BinaryOperator merge, Supplier mapSupplier)) |
| DoubleStream | map<K,V> | 위와 동일                                                                                     |

> ### 10. 스트림 -> 배열

| from         | to       | 변환 메서드                         |
| :----------- | :------- | :---------------------------------- |
| Stream<T>    | object[] | toArray()                           |
| Stream<T>    | T[]      | toArray(IntFunction<A[]> generator) |
| IntStream    | Int[]    | toArray()                           |
| LongStream   | Lont[]   | toArray()                           |
| DoubleStream | Double[] | toArray()                           |
